{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview SIPI is a multithreaded, high-performance, IIIF compatible media server developed by the Data and Service Center for the Humanities at the University of Basel . It is designed to be used by archives, libraries, and other institutions that need to preserve high-quality images while making them available online. SIPI implements the Image API 3.0 of the International Image Interoperability Framework ( IIIF ), and efficiently converts between image formats, preserving metadata contained in image files. In particular, if images are stored in JPEG 2000 format, Sipi can convert them on the fly to formats that are commonly used on the Internet. SIPI offers a flexible framework for specifying authentication and authorization logic in Lua scripts, and supports restricted access to images, either by reducing image dimensions or by adding watermarks. It can easily be integrated with Knora . In addition SIPI preserves most of the EXIF , IPTC and XMP metadata and can preserve or transform ICC color profiles. In addition, a simple webserver is integrated. The server is able to serve most common file types. In addition Lua scripts and embedded Lua (i.e., Lua embedded into HTML pages using the tags <lua>\u2026</lua> are supported. SIPI can also be used from the command line to convert images to/from TIFF-, JPEG 2000 , JPEG- and PNG- formats. For all these conversion, Sipi tries to preserve all embedded metadata such as - IPTC - EXIF - XMP - ICC color profiles. However, due to the limitations of some file formats, it cannot be guaranteed that all metadata and ICC profiles are preserved. - JPEG2000 (J2k) does not allow all types of ICC profiles profiles. Unsupported profile types will be added to the J2k header as comment and will be reinstated if the J2k file is converted back to the TIFF-format. SIPI is a free software , released under the GNU Affero General Public License . It is written in C++ and runs on Linux and macOS. Note: In order to compile SIPI, the user has to provide a licensed source of the kakadu software . It is written in C++ and runs on Linux (including Debian, Ubuntu, and CentOS) and macOS. Freely distributable binary releases are available daschswiss/sipi as docker image.","title":"Overview"},{"location":"#overview","text":"SIPI is a multithreaded, high-performance, IIIF compatible media server developed by the Data and Service Center for the Humanities at the University of Basel . It is designed to be used by archives, libraries, and other institutions that need to preserve high-quality images while making them available online. SIPI implements the Image API 3.0 of the International Image Interoperability Framework ( IIIF ), and efficiently converts between image formats, preserving metadata contained in image files. In particular, if images are stored in JPEG 2000 format, Sipi can convert them on the fly to formats that are commonly used on the Internet. SIPI offers a flexible framework for specifying authentication and authorization logic in Lua scripts, and supports restricted access to images, either by reducing image dimensions or by adding watermarks. It can easily be integrated with Knora . In addition SIPI preserves most of the EXIF , IPTC and XMP metadata and can preserve or transform ICC color profiles. In addition, a simple webserver is integrated. The server is able to serve most common file types. In addition Lua scripts and embedded Lua (i.e., Lua embedded into HTML pages using the tags <lua>\u2026</lua> are supported. SIPI can also be used from the command line to convert images to/from TIFF-, JPEG 2000 , JPEG- and PNG- formats. For all these conversion, Sipi tries to preserve all embedded metadata such as - IPTC - EXIF - XMP - ICC color profiles. However, due to the limitations of some file formats, it cannot be guaranteed that all metadata and ICC profiles are preserved. - JPEG2000 (J2k) does not allow all types of ICC profiles profiles. Unsupported profile types will be added to the J2k header as comment and will be reinstated if the J2k file is converted back to the TIFF-format. SIPI is a free software , released under the GNU Affero General Public License . It is written in C++ and runs on Linux and macOS. Note: In order to compile SIPI, the user has to provide a licensed source of the kakadu software . It is written in C++ and runs on Linux (including Debian, Ubuntu, and CentOS) and macOS. Freely distributable binary releases are available daschswiss/sipi as docker image.","title":"Overview"},{"location":"building/","text":"Building SIPI from Source Code Prerequisites To build SIPI from source code, you must have Kakadu , a JPEG 2000 development toolkit that is not provided with Sipi and must be licensed separately. The Kakadu source code archive v8_0_5-01727L.zip must be placed in the vendor subdirectory of the source tree before building Sipi. Sipi's build process requires CMake (minimal Version 3.0.0), a C++ compiler that supports the C++11 standard (such as GCC or clang ), and several libraries that are readily available on supported platforms. The test framework requires Python 3 , (version 3.5 or later), Apache ab (which is assumed to be installed by default on macOS Sierra), nginx , and a recent version of ImageMagick . Instructions for installing these prerequisites are given below. The build process downloads and builds SIPI's other prerequisites. SIPI uses the Adobe ICC Color profiles, which are automatically downloaded by the build process into the file icc.zip . The user is responsible for reading and agreeing with Adobe's license conditions, which are specified in the file Color Profile EULA.pdf . docker We provide a docker image based on Ubuntu LTS releases, containing all dependencies: https://hub.docker.com/r/dhlabbasel/sipi-base/ If you must build sipi, the preferred way is to build it inside a docker image. Docker must be installed on the system. Then, in the top directory of the source tree, do make compile will download and compile SIPI within a docker container make test to run the full test suite make run to run SIPI in docker image macOS You will need Homebrew and at least OSX 10.11.5. Prerequisites for building Sipi without its automated test framework: xcode-select --install brew install cmake brew install doxygen brew install openssl brew install libmagic brew install gettext brew install libidn If you also want to run Sipi's tests: brew install nginx sudo chown -R $USER /usr/local/var/log/nginx/ brew install imagemagick --with-openjpeg brew install python3 pip3 install Sphinx pip3 install pytest pip3 install requests pip3 install psutil pip3 install iiif_validator Ubuntu 18.04 Prerequisites for building Sipi without its automated test framework: sudo apt-get install g++-7 sudo apt-get install cmake sudo apt-get install libssl-dev sudo apt-get install doxygen sudo apt-get install libreadline-dev sudo apt-get install gettext sudo apt-get install libmagic-dev sudo apt-get install unzip sudo apt-get install libidn11-dev If you also want to run Sipi's tests, you will need ImageMagick , version 7.0.6 or higher. We suggest compiling it from source: sudo apt-get install libtiff5-dev libjpeg-turbo8-dev libopenjp2-7-dev wget https://github.com/ImageMagick/ImageMagick/archive/7.0.6-0.tar.gz tar -xzf 7.0.6-0.tar.gz cd ImageMagick-7.0.6-0/ ./configure make sudo make install sudo ldconfig /usr/local/lib Then: sudo apt-get install ab sudo apt-get install nginx sudo chown -R $USER /var/log/nginx sudo apt-get install python3 sudo apt-get install python3-pip sudo -H pip3 install --upgrade pip sudo -H pip3 install Sphinx sudo -H pip3 install pytest sudo -H pip3 install requests sudo -H pip3 install psutil sudo -H pip3 install iiif_validator Debian 8 First, follow the instructions for ubuntu-build. Then, CMake has to be patched. Unfortunaltely the version of CMake provided by the Debian packages contains a bug and cannot find the OpenSSL libraries and includes. To apply the patch, go to the Sipi dicrectory and run: sudo ./debian-cmake-patch.sh CentOS 7 This requires GCC version 5.3 or greater. You can install it by installing devtoolset-4 , and adding this to your .bash_profile : source scl_source enable devtoolset-4 Prerequisites for building Sipi without its automated test framework: sudo yum -y install cmake3 sudo yum -y install readline-devel sudo yum -y install doxygen sudo yum -y install patch sudo yum -y install openssl-devel sudo yum -y install gettext sudo yum -y install file-devel If you also want to run Sipi's tests, you will need ImageMagick , version 7.0.6 or higher. We suggest compiling it from source: sudo yum install libtiff-devel libjpeg-turbo-devel openjpeg2-devel wget https://github.com/ImageMagick/ImageMagick/archive/7.0.6-0.tar.gz tar -xzf 7.0.6-0.tar.gz cd ImageMagick-7.0.6-0/ ./configure make sudo make install sudo ldconfig /usr/local/lib Then: sudo yum -y install httpd-tools sudo yum -y install nginx sudo chown -R $USER /var/log/nginx sudo chown -R $USER /var/lib/nginx sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpm sudo yum -y install python35u sudo yum -y install python35u-devel sudo yum -y install python35u-pip sudo pip3.5 install Sphinx sudo pip3.5 install pytest sudo pip3.5 install requests sudo pip3.5 install psutil sudo pip3.5 install iiif_validator Docker We provide a docker image based on Ubuntu LTS releases, containing all dependencies: https://hub.docker.com/r/dhlabbasel/sipi-base/ Compiling the Source Code Start in the build subdirectory of the source tree: cd build Then compile Sipi: cmake .. make By default, Sipi is built without optimization and with debug information output. To compile Sipi with optimization level 3, run: cmake .. -DMAKE_DEBUG:BOOL=OFF make Running Tests You can run the automated tests in the build directory like this: make test // will run all tests (minimum output) ctest --verbose // will run all tests (detailed output) make check // will run only e2e tests (detailed output) Making a Directory Tree for Installing Sipi In build , type this to install Sipi in the local subdirectory of the source tree: make install You can then copy the contents of local to the desired location. Generating Documentation To generate this manual in HTML format, cd to the manual subdirectory of the source tree and type: make html You will then find the manual under manual/_build/html . To generate developer documentation about Sipi's C++ internals, cd to the build directory and type: make doc You will find the developer documentation in HTML format under doc/html . To generate developer documentation in PDF format, first ensure that you have LaTeX installed. Then cd to doc/html/latex and type make . Starting Over To delete the previous build and start over from scratch, cd to the top level of the source tree and type: rm -rf build/* lib local extsrcs include/*_icc.h Building inside Docker All that was described before, can also be done by using docker. All commands need to be executed from inside the source directory (and not build the build directory). Also, Docker needs to be installed on the system. // deletes cached image and needs only to be used when newer image is available on dockerhub docker image rm --force dhlabbasel/sipi-base:18.04 // building docker run --rm -v $PWD:/sipi dhlabbasel/sipi-base:18.04 /bin/sh -c \"cd /sipi/build; cmake .. && make\" // building and running all tests docker run --rm -v $PWD:/sipi dhlabbasel/sipi-base:18.04 /bin/sh -c \"cd /sipi/build; cmake .. && make && ctest --verbose\" // make html documentation docker run --rm -v $PWD:/sipi dhlabbasel/sipi-base:18.04 /bin/sh -c \"cd /sipi/manual; make html\" Since we mount the current source directory into the docker container, all build artifacts can be accessed as if the build would have been performed without docker.","title":"Building"},{"location":"building/#building-sipi-from-source-code","text":"","title":"Building SIPI from Source Code"},{"location":"building/#prerequisites","text":"To build SIPI from source code, you must have Kakadu , a JPEG 2000 development toolkit that is not provided with Sipi and must be licensed separately. The Kakadu source code archive v8_0_5-01727L.zip must be placed in the vendor subdirectory of the source tree before building Sipi. Sipi's build process requires CMake (minimal Version 3.0.0), a C++ compiler that supports the C++11 standard (such as GCC or clang ), and several libraries that are readily available on supported platforms. The test framework requires Python 3 , (version 3.5 or later), Apache ab (which is assumed to be installed by default on macOS Sierra), nginx , and a recent version of ImageMagick . Instructions for installing these prerequisites are given below. The build process downloads and builds SIPI's other prerequisites. SIPI uses the Adobe ICC Color profiles, which are automatically downloaded by the build process into the file icc.zip . The user is responsible for reading and agreeing with Adobe's license conditions, which are specified in the file Color Profile EULA.pdf .","title":"Prerequisites"},{"location":"building/#docker","text":"We provide a docker image based on Ubuntu LTS releases, containing all dependencies: https://hub.docker.com/r/dhlabbasel/sipi-base/ If you must build sipi, the preferred way is to build it inside a docker image. Docker must be installed on the system. Then, in the top directory of the source tree, do make compile will download and compile SIPI within a docker container make test to run the full test suite make run to run SIPI in docker image","title":"docker"},{"location":"building/#macos","text":"You will need Homebrew and at least OSX 10.11.5. Prerequisites for building Sipi without its automated test framework: xcode-select --install brew install cmake brew install doxygen brew install openssl brew install libmagic brew install gettext brew install libidn If you also want to run Sipi's tests: brew install nginx sudo chown -R $USER /usr/local/var/log/nginx/ brew install imagemagick --with-openjpeg brew install python3 pip3 install Sphinx pip3 install pytest pip3 install requests pip3 install psutil pip3 install iiif_validator","title":"macOS"},{"location":"building/#ubuntu-1804","text":"Prerequisites for building Sipi without its automated test framework: sudo apt-get install g++-7 sudo apt-get install cmake sudo apt-get install libssl-dev sudo apt-get install doxygen sudo apt-get install libreadline-dev sudo apt-get install gettext sudo apt-get install libmagic-dev sudo apt-get install unzip sudo apt-get install libidn11-dev If you also want to run Sipi's tests, you will need ImageMagick , version 7.0.6 or higher. We suggest compiling it from source: sudo apt-get install libtiff5-dev libjpeg-turbo8-dev libopenjp2-7-dev wget https://github.com/ImageMagick/ImageMagick/archive/7.0.6-0.tar.gz tar -xzf 7.0.6-0.tar.gz cd ImageMagick-7.0.6-0/ ./configure make sudo make install sudo ldconfig /usr/local/lib Then: sudo apt-get install ab sudo apt-get install nginx sudo chown -R $USER /var/log/nginx sudo apt-get install python3 sudo apt-get install python3-pip sudo -H pip3 install --upgrade pip sudo -H pip3 install Sphinx sudo -H pip3 install pytest sudo -H pip3 install requests sudo -H pip3 install psutil sudo -H pip3 install iiif_validator","title":"Ubuntu 18.04"},{"location":"building/#debian-8","text":"First, follow the instructions for ubuntu-build. Then, CMake has to be patched. Unfortunaltely the version of CMake provided by the Debian packages contains a bug and cannot find the OpenSSL libraries and includes. To apply the patch, go to the Sipi dicrectory and run: sudo ./debian-cmake-patch.sh","title":"Debian 8"},{"location":"building/#centos-7","text":"This requires GCC version 5.3 or greater. You can install it by installing devtoolset-4 , and adding this to your .bash_profile : source scl_source enable devtoolset-4 Prerequisites for building Sipi without its automated test framework: sudo yum -y install cmake3 sudo yum -y install readline-devel sudo yum -y install doxygen sudo yum -y install patch sudo yum -y install openssl-devel sudo yum -y install gettext sudo yum -y install file-devel If you also want to run Sipi's tests, you will need ImageMagick , version 7.0.6 or higher. We suggest compiling it from source: sudo yum install libtiff-devel libjpeg-turbo-devel openjpeg2-devel wget https://github.com/ImageMagick/ImageMagick/archive/7.0.6-0.tar.gz tar -xzf 7.0.6-0.tar.gz cd ImageMagick-7.0.6-0/ ./configure make sudo make install sudo ldconfig /usr/local/lib Then: sudo yum -y install httpd-tools sudo yum -y install nginx sudo chown -R $USER /var/log/nginx sudo chown -R $USER /var/lib/nginx sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpm sudo yum -y install python35u sudo yum -y install python35u-devel sudo yum -y install python35u-pip sudo pip3.5 install Sphinx sudo pip3.5 install pytest sudo pip3.5 install requests sudo pip3.5 install psutil sudo pip3.5 install iiif_validator","title":"CentOS 7"},{"location":"building/#docker_1","text":"We provide a docker image based on Ubuntu LTS releases, containing all dependencies: https://hub.docker.com/r/dhlabbasel/sipi-base/","title":"Docker"},{"location":"building/#compiling-the-source-code","text":"Start in the build subdirectory of the source tree: cd build Then compile Sipi: cmake .. make By default, Sipi is built without optimization and with debug information output. To compile Sipi with optimization level 3, run: cmake .. -DMAKE_DEBUG:BOOL=OFF make","title":"Compiling the Source Code"},{"location":"building/#running-tests","text":"You can run the automated tests in the build directory like this: make test // will run all tests (minimum output) ctest --verbose // will run all tests (detailed output) make check // will run only e2e tests (detailed output)","title":"Running Tests"},{"location":"building/#making-a-directory-tree-for-installing-sipi","text":"In build , type this to install Sipi in the local subdirectory of the source tree: make install You can then copy the contents of local to the desired location.","title":"Making a Directory Tree for Installing Sipi"},{"location":"building/#generating-documentation","text":"To generate this manual in HTML format, cd to the manual subdirectory of the source tree and type: make html You will then find the manual under manual/_build/html . To generate developer documentation about Sipi's C++ internals, cd to the build directory and type: make doc You will find the developer documentation in HTML format under doc/html . To generate developer documentation in PDF format, first ensure that you have LaTeX installed. Then cd to doc/html/latex and type make .","title":"Generating Documentation"},{"location":"building/#starting-over","text":"To delete the previous build and start over from scratch, cd to the top level of the source tree and type: rm -rf build/* lib local extsrcs include/*_icc.h","title":"Starting Over"},{"location":"building/#building-inside-docker","text":"All that was described before, can also be done by using docker. All commands need to be executed from inside the source directory (and not build the build directory). Also, Docker needs to be installed on the system. // deletes cached image and needs only to be used when newer image is available on dockerhub docker image rm --force dhlabbasel/sipi-base:18.04 // building docker run --rm -v $PWD:/sipi dhlabbasel/sipi-base:18.04 /bin/sh -c \"cd /sipi/build; cmake .. && make\" // building and running all tests docker run --rm -v $PWD:/sipi dhlabbasel/sipi-base:18.04 /bin/sh -c \"cd /sipi/build; cmake .. && make && ctest --verbose\" // make html documentation docker run --rm -v $PWD:/sipi dhlabbasel/sipi-base:18.04 /bin/sh -c \"cd /sipi/manual; make html\" Since we mount the current source directory into the docker container, all build artifacts can be accessed as if the build would have been performed without docker.","title":"Building inside Docker"},{"location":"developing/","text":"Developing Sipi Using an IDE CLion If you are using the CLion IDE, put -j 1 in Preferences -> Build, Execution, Deployment -> CMake -> Build options, to prevent CMake from building with multiple processes. Also, note that code introspection in the CLion editor may not work until it has run CMake. Code::Blocks If you are using the Code::Blocks_ IDE, you can build a cdb project: cd build cmake .. -G \"CodeBlocks - Unix Makefiles\" Writing Tests We use two test frameworks. We use googletest for unit test and pytest for end-to-end tests. Unit Tests TBA End-to-End Tests To add end-to-end tests, add a Python class in a file whose name begins with test , in the test directory. The class's methods, whose names must also begin with test , should use the manager fixture defined in test/conftest.py , which handles starting and stopping a Sipi server, and provides other functionality useful in tests. See the existing test/test_*.py files for examples. To facilitate testing client HTTP connections in Lua scripts, the manager fixture also starts and stops an nginx instance, which can be used to simulate an authorization server. For example, the provided nginx configuration file, test/nginx/nginx.conf , allows nginx to act as a dummy Knora API server for permission checking: its /v1/files route returns a static JSON file that always grants permission to view the requested file. Commit Message Schema When writing commit messages, we stick to this schema: type (scope): subject body Types: feature (new feature for the user) fix (bug fix for the user) docs (changes to the documentation) style (formatting, etc) refactor (refactoring production code, e.g. renaming a variable) test (adding missing tests, refactoring tests) build (changes to CMake configuration, etc.) enhancement (residual category) Example: feature (HTTP server): support more authentication methods","title":"Developing"},{"location":"developing/#developing-sipi","text":"","title":"Developing Sipi"},{"location":"developing/#using-an-ide","text":"","title":"Using an IDE"},{"location":"developing/#clion","text":"If you are using the CLion IDE, put -j 1 in Preferences -> Build, Execution, Deployment -> CMake -> Build options, to prevent CMake from building with multiple processes. Also, note that code introspection in the CLion editor may not work until it has run CMake.","title":"CLion"},{"location":"developing/#codeblocks","text":"If you are using the Code::Blocks_ IDE, you can build a cdb project: cd build cmake .. -G \"CodeBlocks - Unix Makefiles\"","title":"Code::Blocks"},{"location":"developing/#writing-tests","text":"We use two test frameworks. We use googletest for unit test and pytest for end-to-end tests.","title":"Writing Tests"},{"location":"developing/#unit-tests","text":"TBA","title":"Unit Tests"},{"location":"developing/#end-to-end-tests","text":"To add end-to-end tests, add a Python class in a file whose name begins with test , in the test directory. The class's methods, whose names must also begin with test , should use the manager fixture defined in test/conftest.py , which handles starting and stopping a Sipi server, and provides other functionality useful in tests. See the existing test/test_*.py files for examples. To facilitate testing client HTTP connections in Lua scripts, the manager fixture also starts and stops an nginx instance, which can be used to simulate an authorization server. For example, the provided nginx configuration file, test/nginx/nginx.conf , allows nginx to act as a dummy Knora API server for permission checking: its /v1/files route returns a static JSON file that always grants permission to view the requested file.","title":"End-to-End Tests"},{"location":"developing/#commit-message-schema","text":"When writing commit messages, we stick to this schema: type (scope): subject body Types: feature (new feature for the user) fix (bug fix for the user) docs (changes to the documentation) style (formatting, etc) refactor (refactoring production code, e.g. renaming a variable) test (adding missing tests, refactoring tests) build (changes to CMake configuration, etc.) enhancement (residual category) Example: feature (HTTP server): support more authentication methods","title":"Commit Message Schema"},{"location":"introduction/","text":"Simple Image Presentation Interface (SIPI) - Introduction What is SIPI? 1. A IIIF Image API V3 level 2 conformant image server SIPI is a full multithreaded, high performance, level2 compliant IIIF Image API 3.0 written in C++. For the JPEG2000 implementation, it relies on the commercial kakadu-library , but otherwise it is completely open source on GitHub . It offers special support for multipage PDFs (through a SIPI-specific extensions to the IIIF Image API). SIPI has been designed for the long term preservation of images, intended for the needs of the cultural heritage field. Thus it offers some unique features for this purpose: all file format conversions try to preserve all metadata (EXIF, XMP, IPTC etc.). These functionality is based on the open source exiv2 library . SIPI can deal with and convert ICC color profiles based on the littlecms library . SIPI can embed important preservation data such as the checksum of the pixel values, original filename etc. in the file headers. it supports SSL (https://\u2026) SIPI embeds the scripting language LUA that allows a very flexible, highly customizable deployment that can be adapted to the enviroment SIPI is being used in. Before serving any request, a configurable LUA script (\"pre flight script\") is being executed that can check access rights, restrictions or other stuff. SIPI LUA has been extended with many SIPI-specific functions (including image conversion, HTTP-client etc.) 2. An ordinary HTTP webserver SIPI is also a normal webserver that is able to deliver arbitrary files. It also implements LUA embedded into HTML pages. Using SIPI LUA scripts and routing, RESTful interfaces may be implemented. E.g. image upload and conversions may by supported. 3. An image format conversion tool Generic format conversions image format conversion are supported between TIFF, JPEG2000, JPG, PNG and PDF (PDF with some limitations). SIPI can be used either as standalone command line tool or in server mode using LUA scripting. SIPI preserves most embedded metadata (EXIF, IPTC, TIFF, XMP) and is preserving and/or converting ICC color profiles. Preservation metadata (SIPI specific) SIPI is able to add SIPI specific metadata to most file formats. These metadata are relevant for long-term preservation and include the following information: original filename : The original file name before conversion original mimetype : The mimetype of the original image before conversion pixel checksum : A checksum (e.g. SHA-256) of the original pixel values. This checksum can be used to verify that a format conversion didn't alter the image content. icc profile : (optional) The raw ICC profile as binary string. This field is added if the fileformat has no standard way to embed ICC color profiles (e.g. JPEG). 4. Integrated sqlite3 Database SIPI has an integrated sqlite3 database that can be used with special LUA extensions. Thus, SIPI can be used as a standalone media server with extended functionality. The sqlite3 database may be used to store metadata about images, user data etc. Who is behind SIPI? SIPI is developed and maintained by the \"Data and Service Center for the Humanities\" (DaSCH) , a Swiss national research infrastructure financed by the Swiss National Science Foundation (SNSF) with contributions by the Universities of Basel and Lausanne. How to get SIPI? The easiest way is to use the docker image provided on dockerhup daschswiss/sipi . The dockerized version has the binary kakadu library compiled in. You can compile SIPI from the sources on github . Since SIPI uses many third-party open source libraries, compiling Yourself is tedious and my be frustrating (but possible). You have to provide the licensed source of kakadu by Yourself . See kakadu software on how to get a licensed version of the kakadu code. SIPI should compile on Linux (Ubuntu) and (with some hand-work) OS X. SIPI as IIIF-Server Extensions to the IIIF-Standard Access to PDF Pages SIPI is able to deliver PDF's either as full file or as images using an extended IIIF-URL to access a specific page of a multipage PDF as image using the usual IIIF syntax with small extensions: - In case of a PDF, info.json includes a field numpages that indicates the total number of pages the PDF has - the image-ID given in the IIIF URL must incude a pagenumber specificer @pagenum with an integer between 1 and the maximum number of pages, e.g. https://iiif.dummy.org/images/test.pdf@12/full/,1000/default.jpg The given URL would return page #12 of the PDF test.pdf with a height of 1000 pixels. Thus, all IIIF URL parts will work as expected. Access to non-image files Sometimes it would be helpful to deliver non-image files such as XML, CSV etc. from the same directory tree as the IIIF-conformant images: - if the url has the form http(s)://{server}/{prefix}/{fileid}/info.json , SIPI returns a JSON containing information about the file. The JSON has the from - @context: \"http://sipi.io/api/file/3/context.json\" - id: \"http(s)://{server}/{prefix}/{fileid}\" - mimeType: {mimetype} . Please note that SIPI determines the mimetype using the magic number. Due to the limitations thereof the mimetype cannot be determined exactly.","title":"Introduction"},{"location":"introduction/#simple-image-presentation-interface-sipi-introduction","text":"","title":"Simple Image Presentation Interface (SIPI) - Introduction"},{"location":"introduction/#what-is-sipi","text":"","title":"What is SIPI?"},{"location":"introduction/#1-a-iiif-image-api-v3-level-2-conformant-image-server","text":"SIPI is a full multithreaded, high performance, level2 compliant IIIF Image API 3.0 written in C++. For the JPEG2000 implementation, it relies on the commercial kakadu-library , but otherwise it is completely open source on GitHub . It offers special support for multipage PDFs (through a SIPI-specific extensions to the IIIF Image API). SIPI has been designed for the long term preservation of images, intended for the needs of the cultural heritage field. Thus it offers some unique features for this purpose: all file format conversions try to preserve all metadata (EXIF, XMP, IPTC etc.). These functionality is based on the open source exiv2 library . SIPI can deal with and convert ICC color profiles based on the littlecms library . SIPI can embed important preservation data such as the checksum of the pixel values, original filename etc. in the file headers. it supports SSL (https://\u2026) SIPI embeds the scripting language LUA that allows a very flexible, highly customizable deployment that can be adapted to the enviroment SIPI is being used in. Before serving any request, a configurable LUA script (\"pre flight script\") is being executed that can check access rights, restrictions or other stuff. SIPI LUA has been extended with many SIPI-specific functions (including image conversion, HTTP-client etc.)","title":"1. A IIIF Image API V3 level 2 conformant image server"},{"location":"introduction/#2-an-ordinary-http-webserver","text":"SIPI is also a normal webserver that is able to deliver arbitrary files. It also implements LUA embedded into HTML pages. Using SIPI LUA scripts and routing, RESTful interfaces may be implemented. E.g. image upload and conversions may by supported.","title":"2. An ordinary HTTP webserver"},{"location":"introduction/#3-an-image-format-conversion-tool","text":"","title":"3. An image format conversion tool"},{"location":"introduction/#generic-format-conversions","text":"image format conversion are supported between TIFF, JPEG2000, JPG, PNG and PDF (PDF with some limitations). SIPI can be used either as standalone command line tool or in server mode using LUA scripting. SIPI preserves most embedded metadata (EXIF, IPTC, TIFF, XMP) and is preserving and/or converting ICC color profiles.","title":"Generic format conversions"},{"location":"introduction/#preservation-metadata-sipi-specific","text":"SIPI is able to add SIPI specific metadata to most file formats. These metadata are relevant for long-term preservation and include the following information: original filename : The original file name before conversion original mimetype : The mimetype of the original image before conversion pixel checksum : A checksum (e.g. SHA-256) of the original pixel values. This checksum can be used to verify that a format conversion didn't alter the image content. icc profile : (optional) The raw ICC profile as binary string. This field is added if the fileformat has no standard way to embed ICC color profiles (e.g. JPEG).","title":"Preservation metadata (SIPI specific)"},{"location":"introduction/#4-integrated-sqlite3-database","text":"SIPI has an integrated sqlite3 database that can be used with special LUA extensions. Thus, SIPI can be used as a standalone media server with extended functionality. The sqlite3 database may be used to store metadata about images, user data etc.","title":"4. Integrated sqlite3 Database"},{"location":"introduction/#who-is-behind-sipi","text":"SIPI is developed and maintained by the \"Data and Service Center for the Humanities\" (DaSCH) , a Swiss national research infrastructure financed by the Swiss National Science Foundation (SNSF) with contributions by the Universities of Basel and Lausanne.","title":"Who is behind SIPI?"},{"location":"introduction/#how-to-get-sipi","text":"The easiest way is to use the docker image provided on dockerhup daschswiss/sipi . The dockerized version has the binary kakadu library compiled in. You can compile SIPI from the sources on github . Since SIPI uses many third-party open source libraries, compiling Yourself is tedious and my be frustrating (but possible). You have to provide the licensed source of kakadu by Yourself . See kakadu software on how to get a licensed version of the kakadu code. SIPI should compile on Linux (Ubuntu) and (with some hand-work) OS X.","title":"How to get SIPI?"},{"location":"introduction/#sipi-as-iiif-server","text":"","title":"SIPI as IIIF-Server"},{"location":"introduction/#extensions-to-the-iiif-standard","text":"","title":"Extensions to the IIIF-Standard"},{"location":"introduction/#access-to-pdf-pages","text":"SIPI is able to deliver PDF's either as full file or as images using an extended IIIF-URL to access a specific page of a multipage PDF as image using the usual IIIF syntax with small extensions: - In case of a PDF, info.json includes a field numpages that indicates the total number of pages the PDF has - the image-ID given in the IIIF URL must incude a pagenumber specificer @pagenum with an integer between 1 and the maximum number of pages, e.g. https://iiif.dummy.org/images/test.pdf@12/full/,1000/default.jpg The given URL would return page #12 of the PDF test.pdf with a height of 1000 pixels. Thus, all IIIF URL parts will work as expected.","title":"Access to PDF Pages"},{"location":"introduction/#access-to-non-image-files","text":"Sometimes it would be helpful to deliver non-image files such as XML, CSV etc. from the same directory tree as the IIIF-conformant images: - if the url has the form http(s)://{server}/{prefix}/{fileid}/info.json , SIPI returns a JSON containing information about the file. The JSON has the from - @context: \"http://sipi.io/api/file/3/context.json\" - id: \"http(s)://{server}/{prefix}/{fileid}\" - mimeType: {mimetype} . Please note that SIPI determines the mimetype using the magic number. Due to the limitations thereof the mimetype cannot be determined exactly.","title":"Access to non-image files"},{"location":"lua-image/","text":"Lua image functions Through Lua scripting, SIPI allows a wide aea of utilities to analyze, manipulate and convert images to/from different formats. This functioanlity allows to use SIPI e.g. for offering image upload and converting these images into IIIF conformant long-term storage formats (e.g. JPEG2000). It allows to programmatically modify an image before delivering it to the client, ot to extract data from the images. The basic concept is a specialized Lua image object that offers all methods to manipulate images. SipiImage.new(filename) This method creates a new image object by reading an image file that has to be located somewhere on the SIPI server. The simple forms are: img = SipiImage.new(\"filepath\") img = SipiImage.new(index) The first variant opens a file given by \"filepath\", the second variant opens an uploaded file directly using the integer index to the uploaded files. If the index of an uploaded file is passed as an argument, this method adds additional metadata to the SipiImage object that is constructed: the file's original name, its MIME type, and its SHA256 checksum. When the SipiImage object is then written to another file, this metadata will be stored in an extra header record. If a filename is passed, the method does not add this metadata. The more complex form is as follows: img = SipiImage.new(\"filename\", { region=<iiif-region-string>, size=<iiif-size-string>, reduce=<integer>, original=origfilename, hash=\"md5\"|\"sha1\"|\"sha256\"|\"sha384\"|\"sha512\" }) This creates a new Lua image object and loads the given image into. The second form allows to indicate a region, the size or a reduce factor and the original filename. The hash parameter indicates that the given checksum should be calculated out of the pixel values and written into the header. All parameters are optional, but at least one has to given. The meaning of the parameters are: region : A region in IIIF format the image should be cropped to. size : The size of the resulting image as valid IIIF size string. reduce : An much faster alternative to size, if the image size will be reduced by a integer factor (2=half size, 3=one thrid size etc.) original : The original file name that should be recorded in the metadata hash : The Hash algorithm that will be used for the hash of the pixel values. Valid entries are md5 , sha1 , sha256 , sha384 and sha512 . For example to read an image and include the SIPI preservation metadata, the function is called as follows: SipiImage.new(\"path_to_file\", { original=\"my_image.tif\", hash=\"md5\" } This call will include the preservation metadata (please note that in this case the original filename is mandatory, since Lua has know direct knowledge about the original filename. The filepath given as first parameter must not and normally does not correspond to the original filename). The hash -parameter indicates to use the md5-algorithm for the has of the pixel values. SipiImage.dims() success, dims = img.dims() if success then server.print('nx=', dims.nx, ' ny=', dims.ny) end Returns the pixel dimensions of the image as dims object. SipiImage.crop(<iiif-region-string>) success, errormsg = img.crop(<IIIF-region-string>) Crops the image to the given rectangular region. The parameter must be a valid IIIF-region string. SipiImage.scale(<iiif-size-string>) success, errormsg = img.scale(<iiif-size-string>) Resizes the image to the given size as iiif-conformant size string. SipiImage.rotate(<iiif-rotation-string>) success, errormsg = img.rotate(<iiif-rotation-string>) Rotates and/or mirrors the image according the given iiif-conformant rotation string. SipiImage.watermark(wm-file-path) success, errormsg = img.watermark(wm-file-path) Applies the given watermark file to the image. The watermark file must be a single channel 8-Bit gray value TIFF file. SipiImage.write(filepath, [compression_params]) success, errormsg = img.write(filepath) success, errormsg = img.write('HTTP.jpg') The first version write the image to a file in the SIPI server, the second writes the file to the HTTP connection (which is done whenever the basename of the output file is HTTP ): Parameters: filepath : Path to output file. The file format is determined by the filename extension. Supported are jpg : writes a JPEG file tif : writes a TIFF file png : writes a png file jpx : writes a JPGE2000 file pdf : writes a PDF file compression_params : (optional) An optional Lua table with compression parameters (which are dependent on the chosen output file format!) can be given. All compression parameters are optional. Buf if a compression parameter table is give, it must have at least one entry. JPEG format: quality : Number between 1 and 100 (1 highest compression, worst quality, 100 lowest compression, best quality) JPEG2000 format: Sprofile : Any of PROFILE0 , PROFILE1 , PROFILE2 , PART2 , CINEMA2K , CINEMA4K , BROADCAST , CINEMA2S , CINEMA4S , CINEMASS , IMF . Defaults to PART2 . Creversible : Use the reversible compression algorithms of JPEG2000. Must be string yes or no . Defaults to yes . Clayers : Number of layers to use. Clevels : Number of levels to use. Corder : Ordering of file components. Must be one of the following strings: LRCP , RLCP , RPCL , PCRL or CPRL . Cprecincts : A kakadu conformant precinct string. rates : rates string as used in kakadu. SipiImage.send(format) success, errormsg = img.send(format) Sends the file to the HTTP connection. As format-strings are allowed: jpg : writes a JPEG file tif : writes a TIFF file png : writes a png file jpx : writes a JPGE2000 file SipiImage.mimetype_consistency(mimetype) img.mimetype_consistency(mimetype, original_filename) This method checks if the supplied mimetype (e.g. from received from the browser during upoad), the file according to the magic number ( file signature ) and the file extension are consistent. The parameters are: mimetype : The expected mimetype. filename : The original filename with extension. Please note that mimetype handling can be quite complex, since the correspondence between file extensions and mimetypes is not unambiguous. In addition the file signature can not identify all mimetypes. For example, A \"comma seperated value\" value file (extension .csv ) can have a mimetype of application/csv , text/csv , text/x-csv , application/vnd.ms-excel and more. However, the file signature will usually return text/plain . SIPI tries to cope with these ambiguities.","title":"Lua imaging functions"},{"location":"lua-image/#lua-image-functions","text":"Through Lua scripting, SIPI allows a wide aea of utilities to analyze, manipulate and convert images to/from different formats. This functioanlity allows to use SIPI e.g. for offering image upload and converting these images into IIIF conformant long-term storage formats (e.g. JPEG2000). It allows to programmatically modify an image before delivering it to the client, ot to extract data from the images. The basic concept is a specialized Lua image object that offers all methods to manipulate images.","title":"Lua image functions"},{"location":"lua-image/#sipiimagenewfilename","text":"This method creates a new image object by reading an image file that has to be located somewhere on the SIPI server. The simple forms are: img = SipiImage.new(\"filepath\") img = SipiImage.new(index) The first variant opens a file given by \"filepath\", the second variant opens an uploaded file directly using the integer index to the uploaded files. If the index of an uploaded file is passed as an argument, this method adds additional metadata to the SipiImage object that is constructed: the file's original name, its MIME type, and its SHA256 checksum. When the SipiImage object is then written to another file, this metadata will be stored in an extra header record. If a filename is passed, the method does not add this metadata. The more complex form is as follows: img = SipiImage.new(\"filename\", { region=<iiif-region-string>, size=<iiif-size-string>, reduce=<integer>, original=origfilename, hash=\"md5\"|\"sha1\"|\"sha256\"|\"sha384\"|\"sha512\" }) This creates a new Lua image object and loads the given image into. The second form allows to indicate a region, the size or a reduce factor and the original filename. The hash parameter indicates that the given checksum should be calculated out of the pixel values and written into the header. All parameters are optional, but at least one has to given. The meaning of the parameters are: region : A region in IIIF format the image should be cropped to. size : The size of the resulting image as valid IIIF size string. reduce : An much faster alternative to size, if the image size will be reduced by a integer factor (2=half size, 3=one thrid size etc.) original : The original file name that should be recorded in the metadata hash : The Hash algorithm that will be used for the hash of the pixel values. Valid entries are md5 , sha1 , sha256 , sha384 and sha512 . For example to read an image and include the SIPI preservation metadata, the function is called as follows: SipiImage.new(\"path_to_file\", { original=\"my_image.tif\", hash=\"md5\" } This call will include the preservation metadata (please note that in this case the original filename is mandatory, since Lua has know direct knowledge about the original filename. The filepath given as first parameter must not and normally does not correspond to the original filename). The hash -parameter indicates to use the md5-algorithm for the has of the pixel values.","title":"SipiImage.new(filename)"},{"location":"lua-image/#sipiimagedims","text":"success, dims = img.dims() if success then server.print('nx=', dims.nx, ' ny=', dims.ny) end Returns the pixel dimensions of the image as dims object.","title":"SipiImage.dims()"},{"location":"lua-image/#sipiimagecropiiif-region-string","text":"success, errormsg = img.crop(<IIIF-region-string>) Crops the image to the given rectangular region. The parameter must be a valid IIIF-region string.","title":"SipiImage.crop(&lt;iiif-region-string&gt;)"},{"location":"lua-image/#sipiimagescaleiiif-size-string","text":"success, errormsg = img.scale(<iiif-size-string>) Resizes the image to the given size as iiif-conformant size string.","title":"SipiImage.scale(&lt;iiif-size-string&gt;)"},{"location":"lua-image/#sipiimagerotateiiif-rotation-string","text":"success, errormsg = img.rotate(<iiif-rotation-string>) Rotates and/or mirrors the image according the given iiif-conformant rotation string.","title":"SipiImage.rotate(&lt;iiif-rotation-string&gt;)"},{"location":"lua-image/#sipiimagewatermarkwm-file-path","text":"success, errormsg = img.watermark(wm-file-path) Applies the given watermark file to the image. The watermark file must be a single channel 8-Bit gray value TIFF file.","title":"SipiImage.watermark(wm-file-path)"},{"location":"lua-image/#sipiimagewritefilepath-compression_params","text":"success, errormsg = img.write(filepath) success, errormsg = img.write('HTTP.jpg') The first version write the image to a file in the SIPI server, the second writes the file to the HTTP connection (which is done whenever the basename of the output file is HTTP ): Parameters: filepath : Path to output file. The file format is determined by the filename extension. Supported are jpg : writes a JPEG file tif : writes a TIFF file png : writes a png file jpx : writes a JPGE2000 file pdf : writes a PDF file compression_params : (optional) An optional Lua table with compression parameters (which are dependent on the chosen output file format!) can be given. All compression parameters are optional. Buf if a compression parameter table is give, it must have at least one entry. JPEG format: quality : Number between 1 and 100 (1 highest compression, worst quality, 100 lowest compression, best quality) JPEG2000 format: Sprofile : Any of PROFILE0 , PROFILE1 , PROFILE2 , PART2 , CINEMA2K , CINEMA4K , BROADCAST , CINEMA2S , CINEMA4S , CINEMASS , IMF . Defaults to PART2 . Creversible : Use the reversible compression algorithms of JPEG2000. Must be string yes or no . Defaults to yes . Clayers : Number of layers to use. Clevels : Number of levels to use. Corder : Ordering of file components. Must be one of the following strings: LRCP , RLCP , RPCL , PCRL or CPRL . Cprecincts : A kakadu conformant precinct string. rates : rates string as used in kakadu.","title":"SipiImage.write(filepath, [compression_params])"},{"location":"lua-image/#sipiimagesendformat","text":"success, errormsg = img.send(format) Sends the file to the HTTP connection. As format-strings are allowed: jpg : writes a JPEG file tif : writes a TIFF file png : writes a png file jpx : writes a JPGE2000 file","title":"SipiImage.send(format)"},{"location":"lua-image/#sipiimagemimetype_consistencymimetype","text":"img.mimetype_consistency(mimetype, original_filename) This method checks if the supplied mimetype (e.g. from received from the browser during upoad), the file according to the magic number ( file signature ) and the file extension are consistent. The parameters are: mimetype : The expected mimetype. filename : The original filename with extension. Please note that mimetype handling can be quite complex, since the correspondence between file extensions and mimetypes is not unambiguous. In addition the file signature can not identify all mimetypes. For example, A \"comma seperated value\" value file (extension .csv ) can have a mimetype of application/csv , text/csv , text/x-csv , application/vnd.ms-excel and more. However, the file signature will usually return text/plain . SIPI tries to cope with these ambiguities.","title":"SipiImage.mimetype_consistency(mimetype)"},{"location":"lua/","text":"SIPI Lua Interface SIPI has an embedded LUA interpreter. LUA is a simple script language that was deveopped specifically to be embedded into applications. For example the game minecraft makes extensive use of LUA scripting Each HTTP request to SIPI invokes a new, independent lua-instance. Therefore LUA may be used in the following contexts: Preflight function (mandatory) Embedded in HTML pages RESTful services using the SIPI routing Each lua-instance in SIPI includes additional SIPI-specific information: global variables about the SIPI configuration information about the current HTTP request SIPI specific functions for processing the request and send back information getting image information and transforming images querying and changing the SIPI runtime configuration (e.g. the cache) In general, the SIPI LUA function make use that a Lua function's return value may consist of more than one element (see Multiple Results ): Sipi provides the LuaRocks package manager which must be used in the context of SIPI. The Lua interpreter in Sipi runs in a multithreaded environment: each request runs in its own thread and has its own Lua interpreter. Therefore, only Lua packages that are known to be thread-safe may be used! Pre-flight function The pre-fight function is mandatory and located in the init-script (see configuarion options of SIPI). It is executed after the incoming IIIF HTTP request data has been processed but before an action to respond to the request has been taken. It should be noted that the pre-flight script is only executed for IIIF-specific requests. All other HTTP requests are being directed to \"normal\" HTTP-server part of SIPI. These can utilize the lua functionality by embedding LUA commands within the HTML. The pre-flight function takes 3 parameter: prefix : This is the prefix that is given on the IIIF url [mandatory] http(s)://{server}/ {prefix} /{id}/{region}/{size}/{rotation}/{quality}.{format} Please note that the prefix may contain several \"/\" that can be used as path to the repository file identifier : The image identifier (which must not correspond to an actual filename in the media files repositoy) [mandatory] cookie : A cookie containing authorization information. Usually the cookie cntains a Json Web Token [optional] The pre-flight function must return at least 2 parameters: permission : A string or a table indication the permission to read the image. In a simple case it's either the string \"allow\" or \"deny\" . To allow more flexibility, the following permission tables are supported: Restricted access with watermark. The watermark must be a TIFF file with a single 8-bit channel (gray value image). For example: { type = 'restricted', watermark = './wm/mywatermark.tif' } Restricted access with size limitation. The size must be a IIIF size expression . For example: { type = 'restricted', size='!256,256' } SIPI also supports the IIIF Authentification API . See section IIIF Authentification on how to implement this feature in the pre-flight function. filepath : The path to the master image file in the media files repository. This path can be assembled using the prefix and identifier using any additional information (e.g. accessing a database or using the LUA restful client) The most simple working pre-flight looks as follows assuming that the identifier is the name of the master image file in the repository and the prefix is the path: function pre_flight(prefix, identifier, cookie) { filepath = config.imgroot .. '/' .. prefix .. '/' .. identifier return 'allow', filepath } Above function allows all files to be served without restriction. The following example uses some SIPI lua funtions to access a authorization server to check if the user (identified by a cookie) is allowed to see the specific image. We are using Json Web Tokens (JWT) which are supported by SIPI specific LUA functions. Please note that the SIPI JTW-functions support an arbitrary payload that has not to follow the JWT recommendations. In order to encode, the JWT_ALG_HS256 is beeing used together with the key that is defined in the SIPI configuration as jwt_secret . function pre_flight(prefix, identifier, cookie) { -- -- make up the file path -- local filepath = config.imgroot .. '/' .. prefix .. '/' .. identifier -- -- we need a cookie containing the user inforamtion that will be -- sent to the authorization server. In this -- example, the content does not follow the JWT rules -- (which is possible to pack any table into a JWT encoded token) -- if cookie then -- -- we decode the cookie in order to get a table of key/value pairs -- success, userinfo = server.decode_jwt(cookie) if not success then return 'deny', filepath end -- -- prepare the RESTful call to the authorization server -- -- add the image identifier to the info table: userinfo[\"imgid\"] = identifier -- encode the userinfo to a JWT-like token: local new_cookie = server.generate_jwt(userinfo) local url = 'http://auth.institution.org/api/getauth/' .. identifier local auth_information = { Cookie = new_cookie } -- -- make the HTTP request with a timeout of 500 ms -- success, result = server.http('GET', url, auth_information, 500) if success then -- -- we got a response from the server -- success, response_json = server.json_to_table(result.body) if success then -- everything OK return { type = response_json.type, restriction = response_json.restriction }, filepath else return 'deny', filepath end else return 'deny', filepath end else return 'deny', filepath end } Above example assumes that the cookie data is a string that contains encrypted user data from a table (key/value pair). Jason Web Token. This token is decoded and the information about the image to be displayed is added. Then the information is encoded as a new token that ist transmitted to the RESTful interface of the authentification server. The answer is assumed to be json containing information about the type ('allow', 'deny', 'restricted') and the restriction settings. The pre-flight function uses the following SIPI-specific LUA global variables and function: config.imgroot : (Global variable) Root directory of the image repository. server.http() : (Function) Used to create a RESTful GET request. server.generate_jwt() : (Function) Create a new JWT token from a key/value table. server.json_to_table() : (function) Convert a JSON into a LUA table. LUA embedded in HTML The HTTP server that is included in SIPI can serve any type of file which are just transfered as is to the client. However, if a file has an extension of .elua , it is assumed to be a HTML file with embedded LUA code. ALL SIPI-specific LUA functions and global variables are available. Embedding works with the special tag <lua> and </lua> . All text between the opening and closing tag is interpreted as LUA code. SIPI provides an extra LUA function to output data to the client ( server.print ). Thus, dynamic, server-generated HTML may be created. A sample page that displays some information about the server configuration and client info could like follows: <html> <head> <title>SIPI Configuration Info</title> </head> <body> <h1>SIPI Configuration Info</h1> <h2>Configuration variables</h2> <table> <tr> <td>imgroot</td> <td>:</td> <td><lua>server.print(config.imgroot)</lua></td> </tr> <tr> <td>docroot</td> <td>:</td> <td><lua>server.print(server.docroot)</lua></td> </tr> <tr> <td>hostname</td> <td>:</td> <td><lua>server.print(config.hostname)</lua></td> </tr> <tr> <td>scriptdir</td> <td>:</td> <td><lua>server.print(config.scriptdir)</lua></td> </tr> <tr> <td>cachedir</td> <td>:</td> <td><lua>server.print(config.cache_dir)</lua></td> </tr> <tr> <td>tmpdir</td> <td>:</td> <td><lua>server.print(config.tmpdir)</lua></td> </tr> <tr> <td>port</td> <td>:</td> <td><lua>server.print(config.port)</lua></td> </tr> <lua> if server.has_openssl then server.print('<tr><td>SSL port</td><td>:</td><td>' .. config.sslport .. '</td></tr>') end </lua> <tr> <td>number of threads:</td> <td>:</td> <td><lua>server.print(config.n_threads)</lua></td> </tr> <tr> <td>maximal post size:</td> <td>:</td> <td><lua>server.print(config.max_post_size)</lua></td> </tr> </table> <h2>Client information</h2> <table> <tr> <td>Host in request</td> <td>:</td> <td><lua>server.print(server.host)</lua></td> </tr> <tr> <td>IP of client</td> <td>:</td> <td><lua>server.print(server.client_ip)</lua></td> </tr> <tr> <td>URL path</td> <td>:</td> <td><lua>server.print(server.uri)</lua></td> </tr> </table> <p>Important Note: \"IP of client\" and \"Host in request\" may indicate the information of a proxy and notof the actual client!</p> <h2>Request Header Information</h2> <table> <lua> for key, val in pairs(server.header) do server.print('<tr><td>' .. key .. '</td><td>:</td><td>' .. val . '</td></tr>') end </lua> </table> </body> </html> Embedded LUA and enforcing SSL The supplied init-file offers a LUA function that enforces the use of a SSL encryption page proteced by a user name and password. It is used as follows by adding the following code before the <html> opening tag : <lua> if server.secure then protocol = 'https://' else protocol = 'http://' end success,token = authorize_page('admin.sipi.org', 'administrator', extecteduser, expectedPassword) if not success then return end </lua> where expectedUser and extectedPassword are the user/password combination the user is expected to enter. File uploads to SIPI The SIPI specific LUA function allow the upload of files using POST requests with multipart/form-data content. The global variable server.uploads contains`the information about the uploads. The following variables and function help to deal with uploads: server.uploads : information about the files in the upload request. server.copyTmpfile : copies a fie from the upload location to the destination directory. In addition the file system functions that SIPI provides may be used. See the scripts upload.elua and do-upload.elua in the server directory, and upload.lua in the scripts directory for a working example. RESTful API and custom routes Custom routes to implement a RESTful API can be defined in Sipi's configuration file using the routes configuration variable. For example: routes = { { method = 'GET', route = '/status', script = 'get_repository_status.lua' }, { method = 'POST', route = '/make_thumbnail', script = 'make_image_thumbnail.lua' } } Sipi looks for these scripts in the directory specified by scriptdir in its configuration file. The first route that matches the beginning of the requested URL path will be used. IIIF Authentication API 1.0 in SIPI The pre_flight function is also responsible for activating the IIIF Auth API. In order to do so, the pre_flight script returns a table that contains all necessary information. For details about the IIIF Authentication API 1.0 see the IIIF documentation . The following fields have to be returned by the pre_flight -function as LUA-table: type : String giving the type. Valid are: \"login\" , \"clickthrough\" , \"\"kiosk\" or \"external\" . cookieUrl : URL where to get a valid IIIF Auth cookie for this service. tokenUrl : URL where to get a valid IIIF Auth token for this service. confirmLabel : Label to display in confirmation box. description : Description for login window. failureDescription : Information, if login fails. failureHeader : Header for failure window. header : Header of login window label : Label of the login window In addition, the filepath has to be returns. A full response may look as follows: return { type = 'login', cookieUrl = 'https://localhost/iiif-cookie.html', tokenUrl = 'https://localhost/iiif-token.php', confirmLabel = 'Login to SIPI', description = 'This Example requires a demo login!', failureDescription = '<a href=\"http://example.org/policy\">Access Policy</a>', failureHeader = 'Authentication Failed', header = 'Please Log In', label = 'Login to SIPI', }, filepath SIPI will use this information returned by the pre_flight function to return the appropriate responses to the client requests based on the IIIF Authentication API 1.0. Check for support of the IIIF Authentication API 1.0 for mirador and universalviewer , both applications which suppport the IIIF standards. SIPI variables available to Lua scripts There are many globally accessible LUA variables made available which reflext the configuration of SIPI and the state of the server and request. This variables a read only and created for every request. SIPI configuration variables This variables are defined ither in the configuration file if SIPI, in environemt variables at startup or as command line option when starting the server. config.hostname config.hostname The hostname SIPI is configures to run on (see hostname in configuration description). config.port config.port Portnumber where the SIPI server listens (see serverport in configuration description). config.sslport config.sslport Portnumber for SSL connections of SIPI (see sslport in configuration description). config.imgroot config.imgroot Root directory for IIIF-served images (see imgroot in configuration description). config.docroot config.docroot Root directory for WEB-Server (see docroot in configuration description). config.max_temp_file_age config.max_temp_file_age maximum age of temporary files (see max_temp_file_age in configuration description). config.prefix_as_path config.prefix_as_path` true if the prefix should be used as path info (see prefix_as_path in configuration description). config.init_script config.init_script Path to initialization script (see initscript in configuration description). config.scriptdir config.scriptdir Path to script directory. (see scriptdir in configuration description). config.cache_dir config.cache_dir Path to cache directory for iIIF served images. (see cachedir in configuration description). config.cache_size config.cache_size Maximal size of cache (see cachesize in configuration description). config.cache_n_files config.cache_n_files Maximal number of files in cache. (see cache_nfiles in configuration description). config.cache_hysteresis config.cache_hysteresis Amount of data to be purged if cache reaches maximum size. (see cache_hysteresis in configuration description). config.jpeg_quality config.jpeg_quality Unfortunately, the IIIF Image API does not allow to give a JPEG quality (=compression) on the IIIF URL. SIPI allows to configure the compression quality system wide with this parameter. Allowed values are in he range [1..100] where 1 the worst quality (and highest compression factor = smallest file size) and 100 the highest quality (with lowest compression factor = biggest file size). Please note that SIPI is not able to provide lossless compression for JPEG files. (see jpeg_quality in configuration description). config.keep_alive config.keep_alive Maximal keep-alive time for HTTP requests that ask for a keep-alive connection. (see keep_alive in configuration description). config.thumb_size config.thumb_size Default thumbnail image size. (see thumb_size in configuration description). config.n_threads config.n_threads Number of worker threads SIPI uses. (see nthreads in configuration description). config.max_post_size config.max_post_size Maximal size of POST data allowed (see max_post_size in configuration description). config.tmpdir config.tmpdir Temporary directory to store uploads. (see tmpdir in configuration description). config.ssl/_certificate config.ssl_certificate Path to the SSL certificate that SIPI uses. (see ssl_certificate in configuration description). config.ssl/_key config.ssl_key Path to the SSL key that SIPI uses. (see ssl_key in configuration description). config.logfile config.logfile Name of the logfile. SIPI is currently using the syslog facility and the logfile name is ignored. (see logfile in configuration description). config.loglevel config.loglevel Indicates what should be logged. The variable contains a integer that corresponds to the syslog level. (see loglevel in configuration description). config.adminuser config.adminuser Name of admin user. (see user in configuration description). config.password config.password Password (plain text, not encrypted) of admin user ( use with caution )! (see password in configuration description). SIPI Server Variables Sipi server variables are dependent on the incoming request and are created by SIPI automatically for each request. server.method server.method The HTTP request method. Is one of OPTIONS , GET , HEAD , POST , PUT , DELETE , TRACE , CONNECT or OTHER . server.has_openssl server.has_openssl true if OpenSSL is available. This variable is determined compilation time. Usually SSL should be included, but SIPI can be compiled without SSL support. There is no option in the configuration file for this. server.secure server.secure true if the connection was made over HTTPS using SSL. server.host server.host The hostname of the Sipi server that was used in the request. server.client_ip server.client_ip The IPv4 or IPv6 address of the client connecting to Sipi. server.client_port server.client_port The port number of the client socket. server.uri server.uri The URL path used to access Sipi (does not include the hostname). server.header server.header A table containing all the HTTP request headers(in lowercase). server.cookies server.cookies A table of the cookies that were sent with the request. server.get server.get A table of GET request parameters. server.post server.post A table of POST or PUT request parameters. server.request server.request All request parameters. server.content server.content If the request had a body, the variable contains the body data. Otherwise it's nil . server.content_type server.content_type Returns the content type of the request. If there is no type or no content, this variable is nil . server.uploads server.uploads This is an array of upload parameters, one per file. Each one is a table containing: fieldname : the name of the form field. origname : the original filename. tmpname : a temporary path to the uploaded file. mimetype : the MIME type of the uploaded file as provided by the browser. filesize : the size of uploaded file in bytes. The upload can be accessed as follows: for index, value in pairs(server.uploads) do -- -- copy the uploaded file to the image repository using the original name -- server.copyTmpfile(index, config.imgdir .. '/' .. value[\"origname\"]) end Knora-specific variables The development of SIPI came out of the need to have a flexible, high performance IIIF server for the Swiss National research infrastructure Data and Service Center for the Humanities (DaSCH). The aim of the DaSCH is to guarantee long-term accessibility of research data from the Humanities. The operates a specialized platform Knora . The following variables are for internal use only. config.knora_path config.knora_path Path to knora REST API (only for SIPI used with Knora) config.knora_port config.knora_port Port that the Knora API uses SIPI functions available to Lua scripts Sipi provides the following functions that can be called from Lua scripts. Each function returns two values. The first value is true if the operation succeeded, false otherwise. If the operation succeeded, the second value is the result of the operation, otherwise it is an error message. SIPI Connection Functions These LUA function alter the way the HTTP connection is handled. server.setBuffer success, errmsg = server.setBuffer([bufsize][,incsize]) Activates the the connection buffer. Optionally the buffer size and increment size can be given. Returns true, nil on success or false, errormsg on failure. server.sendHeader success, errormsg = server.sendHeader(key, value) Sets an HTTP response header. Returns true, nil on success or false, errormsg on failure. server.sendCookie success, errormsg = server.sendCookie(key, value [, options-table]) Sets a cookie in the HTTP response. Returns true, nil on success or false, errormsg on failure. The optional options-table is a Lua table containing the following keys: path domain expires (value in seconds) secure (boolean) http_only (boolean) server.sendStatus server.sendStatus(code) Sends an HTTP status code. This function is always successful and returns nothing. server.print success, errormsg = server.print(values) Prints variables and/or strings over the HTTP connection to the client that originated the request. Returns true, nil on success or false, errormsg on failure. server.requireAuth success, table = server.requireAuth() This function retrieves HTTP authentication data that was supplied after sending a 'WWW-Authenticate' -header (e.g. by issuing a the following commands to enter the HTTP login dialog: server.setBuffer() server.sendStatus(401); server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') It returns true, table on success or false, errormsg on failure. The result of the authorization is returned as table with the following elements: status : Either BASIC , BEARER , NOAUTH (no authorization header) or ERROR username : A string containing the supplied username (only existing if stats is BASIC ) password : A string containing the supplied password (only existing if stats is BASIC ) token : A string containing the raw token information (only if status BEARER ) message : A string containing the error message (only if status ERROR ) Example: success, auth = server.requireAuth() if not success then server.sendStatus(501) server.print(\"Error in getting authentication scheme!\") return -1 end if auth.status == 'BASIC' then -- -- everything OK, let's create the token for further -- calls and ad it to a cookie -- if auth.username == config.adminuser and auth.password == config.password then tokendata = { iss = \"sipi.unibas.ch\", aud = \"knora.org\", user = auth.username } success, token = server.generate_jwt(tokendata) if not success then server.sendStatus(501) server.print(\"Could not generate JWT!\") return -1 end success, errormsg = server.sendCookie('sipi', token, {path = '/', expires = 3600}) if not success then server.sendStatus(501) server.print(\"Couldn't send cookie with JWT!\") return -1 end else server.sendStatus(401) server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') server.print(\"Wrong credentials!\") return -1 end elseif auth.status == 'BEARER' then success, jwt = server.decode_jwt(auth.token) if not success then server.sendStatus(501) server.print(\"Couldn't deocde JWT!\") return -1 end if (jwt.iss ~= 'sipi.unibas.ch') or (jwt.aud ~= 'knora.org') or (jwt.user ~= config.adminuser) then server.sendStatus(401) server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') return -1 end elseif auth.status == 'NOAUTH' then server.setBuffer() server.sendStatus(401); server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') return -1 else server.status(401) server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') return -1 end SIPI File System Function These functions offer tools to manipuale files and directories, and to gather file information. server.fs.ftype success, filetype = server.fs.ftype(filepath) Checks the filetype of a given filepath. Returns either true, filetype (with filetype one of \"FILE\" , \"DIRECTORY\" , \"CHARDEV\" , \"BLOCKDEV\" , \"LINK\" , \"SOCKET\" or \"UNKNOWN\" ) or false, errormsg . server.fs.modtime success, modtime = server.fs.modtime(filepath) Retrieves the last modification date of a file in seconds since epoch UTC. Returns either true , modtime or false , errormsg . server.fs.is_readable success, readable = server.fs.is_readable(filepath) Checks if a file is readable. Returns true, readable (boolean) on success or false, errormsg on failure. server.fs.is_writeable success, writeable = server.fs.is_writeable(filepath) Checks if a file is writeable. Returns true, writeable (boolean) on success or false, errormsg on failure. server.fs.is_executable success, errormsg = server.fs.is_executable(filepath) Checks if a file is executable. Returns true, executable (boolean) on success or false, errormsg on failure. server.fs.exists success, exists = server.fs.exists(filepath) Checks if a file exists. Checks if a file exists. Returns true, exists (boolean) on success or false, errormsg on failure. server.fs.unlink success, errormsg = server.fs.unlink(filename) Deletes a file from the file system. The file must exist and the user must have write access. Returns true, nil on success or false, errormsg on failure. server.fs.mkdir success, errormsg = server.fs.mkdir(dirname, [tonumber('0755', 8)]) Creates a new directory, optionally with the specified permissions. Returns true, nil on success or false, errormsg on failure. server.fs.rmdir success, errormsg = server.fs.rmdir(dirname) Deletes a directory. Returns true, nil on success or false, errormsg on failure. server.fs.getcwd success, curdir = server.fs.getcwd() Gets the current working directory. Returns true, current_dir on success or false, errormsg on failure. server.fs.readdir success, filenames = server.fs.readdir(dirname) Gets the names of the files in a directory, not including . and .. . Returns true, table on success or false, errormsg on failure. server.fs.chdir success, oldir = server.fs.chdir(newdir) Change working directory. Returns true, olddir on success or false, errormsg on failure. server.fs.copyFile success, errormsg = server.fs.copyFile(source, destination) Copies a file from source to destination. Returns true, nil on success or false, errormsg on failure. server.fs.moveFile success, errormsg = server.fs.moveFile(from, to) Moves a file. The move connot cross filesystem boundaries! true, nil on success or false, errormsg on failure. Other Helper Function server.http success, result = server.http(method, \"http://server.domain[:port]/path/file\" [, header] [, timeout]) Performs an HTTP request using curl. Currently implements only GET requests. Parameters: method : The HTTP request method. Currently must be \"GET\" . url : The HTTP URL. header : An optional table of key-value pairs representing HTTP request headers. timeout : An optional number of milliseconds until the connection times out. Authentication is not yet supported. The result is a table: result = { status_code = value -- HTTP status code returned erromsg = \"error description\" -- only if success is false header = { name = value [, name = value, ...] }, certificate = { -- only if HTTPS connection subject = value, issuer = value }, body = data, duration = milliseconds } Example: success, result = server.http(\"GET\", \"http://www.salsah.org/api/resources/1\", 100) if (result.success) then server.print(\"<table>\") server.print(\"<tr><th>Field</th><th>Value</th></tr>\") for k,v in pairs(server.header) do server.print(\"<tr><td>\", k, \"</td><td>\", v, \"</td></tr>\") end server.print(\"</table><hr/>\") server.print(\"Duration: \", result.duration, \" ms<br/><hr/>\") server.print(\"Body:<br/>\", result.body) else server.print(\"ERROR: \", result.errmsg) end server.table_to_json success, jsonstr = server.table\\_to\\_json(table) Converts a (nested) Lua table to a JSON string. Returns true, jsonstr on success or false, errormsg on failure. server.json_to_table success, table = server.json_to_table(jsonstr) Converts a JSON string to a (nested) Lua table. Returns true, table on success or false, errormsg on failure. server.generate_jwt success, token = server.generate_jwt(table) Generates a JSON Web Token (JWT) with the supplied table as payload. Returns true, token on success or false, errormsg on failure. The internal may contain arbitrary keys and/or may contains the JWT claims as follows. (The type IntDate is a number of seconds since 1970-01-01T0:0:0Z): iss (string => StringOrURI) OPT: principal that issued the JWT. exp (number => IntDate) OPT: expiration time on or after which the token MUST NOT be accepted for processing. nbf (number => IntDate) OPT: identifies the time before which the token MUST NOT be accepted for processing. iat (number => IntDate) OPT: identifies the time at which the JWT was issued. aud (string => StringOrURI) OPT: identifies the audience that the JWT is intended for. The audience value is a string, typically the base address of the resource being accessed, such as https://contoso.com . prn (string => StringOrURI) OPT: identifies the subject of the JWT. jti (string => String) OPT: provides a unique identifier for the JWT. server.decode_jwt success, table = server.decode_jwt(token) Decodes a JSON Web Token (JWT) and returns its content as table. Returns true, table on success or false, errormsg on failure. server.parse_mimetype success, mimetype = server.parse_mimetype(str) Parses a mimtype HTTP header string and returns a pair containing the actual mimetype and the charset used (if available). It returns true, pair with pair as mimetype and charset on success, false, errormsg on failure. server.file_mimetype success, table = server.file_mimetype(path) success, table = server.file_mimetype(index) Determines the mimetype of a file. The first form is used if the file path is known. The second form can be used for uploads by passing the upload file index. It returns true, table on success or false, errormsg on failure. The table has 2 members: - mimetype - charset server.file_mimeconsistency success, is_consistent = server.file_mimeconsistency(path) success, is_consistent = server.file_mimeconsistency(index) Checks if the file extension and the mimetype determined by the magic of the file is consistent. The first form requires a path (including the filename with extension), the second can be used for checking uploads by passing the file index. It returns true, is_consistent on success or false, errormsg in case of an error. is_consistent is true if the mimetype corresponds to the file extension. server.copyTmpfile success, errormsg = server.copyTmpfile(from, to) Sipi saves each uploaded file in a temporary location (given by the config variable tmpdir ) and deletes it after the request has been served. This function is used to copy the file to another location where it can be retrieved later. Returns true, nil on success or false, errormsg on failure. Parameters: from : an index (integer value) of array server.uploads. target : destination path server.systime systime = server.systime() Returns the current system time on the server in seconds since epoch. server.log server.log(message, loglevel) Writes a message to syslog . Severity levels are: server.loglevel.LOG_EMERG server.loglevel.LOG_ALERT server.loglevel.LOG_CRIT server.loglevel.LOG_ERR server.loglevel.LOG_WARNING server.loglevel.LOG_NOTICE server.loglevel.LOG_INFO server.loglevel.LOG_DEBUG server.uuid success, uuid = server.uuid() Generates a random UUID version 4 identifier in canonical form, as described in RFC 4122 . Returns true, uuid on success or false, errormsg on failure. server.uuid62 success, uuid62 = server.uuid62() Generates a Base62-encoded UUID. Returns true, uuid62 on success or false, errormsg on failure. server.uuid_to_base62 success, uuid62 = server.uuid_to_base62(uuid) Converts a canonical UUID string to a Base62-encoded UUID. Returns true, uuid62 on success or false, errormsg on failure. server.base62_to_uuid success, uuid = server.base62_to_uuid(uuid62) Converts a Base62-encoded UUID to canonical form. Returns true, uuid on success or false, errormsg on failure. Installing Lua modules To install Lua modules that can be used in Lua scripts, use local/bin/luarocks . Make sure that the location where the modules are stored is in the Lua package path, which is printed by local/bin/lurocks path. The Lua paths will be used by the Lua interpreter when loading modules in a script with require (see Using LuaRocks to install packages in the current directory ). For example, using local/bin/luarocks install --local package , the package will be installed in ~/.luarocks/ . To include this path in the Lua's interpreter package search path, you can use an environment variable. Running local/bin/luarocks path outputs the code you can use to do so. Alternatively, you can build the package path at the beginning of a Lua file by setting package.path and package.cpath (see Running scripts with packages ).","title":"Lua integration"},{"location":"lua/#sipi-lua-interface","text":"SIPI has an embedded LUA interpreter. LUA is a simple script language that was deveopped specifically to be embedded into applications. For example the game minecraft makes extensive use of LUA scripting Each HTTP request to SIPI invokes a new, independent lua-instance. Therefore LUA may be used in the following contexts: Preflight function (mandatory) Embedded in HTML pages RESTful services using the SIPI routing Each lua-instance in SIPI includes additional SIPI-specific information: global variables about the SIPI configuration information about the current HTTP request SIPI specific functions for processing the request and send back information getting image information and transforming images querying and changing the SIPI runtime configuration (e.g. the cache) In general, the SIPI LUA function make use that a Lua function's return value may consist of more than one element (see Multiple Results ): Sipi provides the LuaRocks package manager which must be used in the context of SIPI. The Lua interpreter in Sipi runs in a multithreaded environment: each request runs in its own thread and has its own Lua interpreter. Therefore, only Lua packages that are known to be thread-safe may be used!","title":"SIPI Lua Interface"},{"location":"lua/#pre-flight-function","text":"The pre-fight function is mandatory and located in the init-script (see configuarion options of SIPI). It is executed after the incoming IIIF HTTP request data has been processed but before an action to respond to the request has been taken. It should be noted that the pre-flight script is only executed for IIIF-specific requests. All other HTTP requests are being directed to \"normal\" HTTP-server part of SIPI. These can utilize the lua functionality by embedding LUA commands within the HTML. The pre-flight function takes 3 parameter: prefix : This is the prefix that is given on the IIIF url [mandatory] http(s)://{server}/ {prefix} /{id}/{region}/{size}/{rotation}/{quality}.{format} Please note that the prefix may contain several \"/\" that can be used as path to the repository file identifier : The image identifier (which must not correspond to an actual filename in the media files repositoy) [mandatory] cookie : A cookie containing authorization information. Usually the cookie cntains a Json Web Token [optional] The pre-flight function must return at least 2 parameters: permission : A string or a table indication the permission to read the image. In a simple case it's either the string \"allow\" or \"deny\" . To allow more flexibility, the following permission tables are supported: Restricted access with watermark. The watermark must be a TIFF file with a single 8-bit channel (gray value image). For example: { type = 'restricted', watermark = './wm/mywatermark.tif' } Restricted access with size limitation. The size must be a IIIF size expression . For example: { type = 'restricted', size='!256,256' } SIPI also supports the IIIF Authentification API . See section IIIF Authentification on how to implement this feature in the pre-flight function. filepath : The path to the master image file in the media files repository. This path can be assembled using the prefix and identifier using any additional information (e.g. accessing a database or using the LUA restful client) The most simple working pre-flight looks as follows assuming that the identifier is the name of the master image file in the repository and the prefix is the path: function pre_flight(prefix, identifier, cookie) { filepath = config.imgroot .. '/' .. prefix .. '/' .. identifier return 'allow', filepath } Above function allows all files to be served without restriction. The following example uses some SIPI lua funtions to access a authorization server to check if the user (identified by a cookie) is allowed to see the specific image. We are using Json Web Tokens (JWT) which are supported by SIPI specific LUA functions. Please note that the SIPI JTW-functions support an arbitrary payload that has not to follow the JWT recommendations. In order to encode, the JWT_ALG_HS256 is beeing used together with the key that is defined in the SIPI configuration as jwt_secret . function pre_flight(prefix, identifier, cookie) { -- -- make up the file path -- local filepath = config.imgroot .. '/' .. prefix .. '/' .. identifier -- -- we need a cookie containing the user inforamtion that will be -- sent to the authorization server. In this -- example, the content does not follow the JWT rules -- (which is possible to pack any table into a JWT encoded token) -- if cookie then -- -- we decode the cookie in order to get a table of key/value pairs -- success, userinfo = server.decode_jwt(cookie) if not success then return 'deny', filepath end -- -- prepare the RESTful call to the authorization server -- -- add the image identifier to the info table: userinfo[\"imgid\"] = identifier -- encode the userinfo to a JWT-like token: local new_cookie = server.generate_jwt(userinfo) local url = 'http://auth.institution.org/api/getauth/' .. identifier local auth_information = { Cookie = new_cookie } -- -- make the HTTP request with a timeout of 500 ms -- success, result = server.http('GET', url, auth_information, 500) if success then -- -- we got a response from the server -- success, response_json = server.json_to_table(result.body) if success then -- everything OK return { type = response_json.type, restriction = response_json.restriction }, filepath else return 'deny', filepath end else return 'deny', filepath end else return 'deny', filepath end } Above example assumes that the cookie data is a string that contains encrypted user data from a table (key/value pair). Jason Web Token. This token is decoded and the information about the image to be displayed is added. Then the information is encoded as a new token that ist transmitted to the RESTful interface of the authentification server. The answer is assumed to be json containing information about the type ('allow', 'deny', 'restricted') and the restriction settings. The pre-flight function uses the following SIPI-specific LUA global variables and function: config.imgroot : (Global variable) Root directory of the image repository. server.http() : (Function) Used to create a RESTful GET request. server.generate_jwt() : (Function) Create a new JWT token from a key/value table. server.json_to_table() : (function) Convert a JSON into a LUA table.","title":"Pre-flight function"},{"location":"lua/#lua-embedded-in-html","text":"The HTTP server that is included in SIPI can serve any type of file which are just transfered as is to the client. However, if a file has an extension of .elua , it is assumed to be a HTML file with embedded LUA code. ALL SIPI-specific LUA functions and global variables are available. Embedding works with the special tag <lua> and </lua> . All text between the opening and closing tag is interpreted as LUA code. SIPI provides an extra LUA function to output data to the client ( server.print ). Thus, dynamic, server-generated HTML may be created. A sample page that displays some information about the server configuration and client info could like follows: <html> <head> <title>SIPI Configuration Info</title> </head> <body> <h1>SIPI Configuration Info</h1> <h2>Configuration variables</h2> <table> <tr> <td>imgroot</td> <td>:</td> <td><lua>server.print(config.imgroot)</lua></td> </tr> <tr> <td>docroot</td> <td>:</td> <td><lua>server.print(server.docroot)</lua></td> </tr> <tr> <td>hostname</td> <td>:</td> <td><lua>server.print(config.hostname)</lua></td> </tr> <tr> <td>scriptdir</td> <td>:</td> <td><lua>server.print(config.scriptdir)</lua></td> </tr> <tr> <td>cachedir</td> <td>:</td> <td><lua>server.print(config.cache_dir)</lua></td> </tr> <tr> <td>tmpdir</td> <td>:</td> <td><lua>server.print(config.tmpdir)</lua></td> </tr> <tr> <td>port</td> <td>:</td> <td><lua>server.print(config.port)</lua></td> </tr> <lua> if server.has_openssl then server.print('<tr><td>SSL port</td><td>:</td><td>' .. config.sslport .. '</td></tr>') end </lua> <tr> <td>number of threads:</td> <td>:</td> <td><lua>server.print(config.n_threads)</lua></td> </tr> <tr> <td>maximal post size:</td> <td>:</td> <td><lua>server.print(config.max_post_size)</lua></td> </tr> </table> <h2>Client information</h2> <table> <tr> <td>Host in request</td> <td>:</td> <td><lua>server.print(server.host)</lua></td> </tr> <tr> <td>IP of client</td> <td>:</td> <td><lua>server.print(server.client_ip)</lua></td> </tr> <tr> <td>URL path</td> <td>:</td> <td><lua>server.print(server.uri)</lua></td> </tr> </table> <p>Important Note: \"IP of client\" and \"Host in request\" may indicate the information of a proxy and notof the actual client!</p> <h2>Request Header Information</h2> <table> <lua> for key, val in pairs(server.header) do server.print('<tr><td>' .. key .. '</td><td>:</td><td>' .. val . '</td></tr>') end </lua> </table> </body> </html>","title":"LUA embedded in HTML"},{"location":"lua/#embedded-lua-and-enforcing-ssl","text":"The supplied init-file offers a LUA function that enforces the use of a SSL encryption page proteced by a user name and password. It is used as follows by adding the following code before the <html> opening tag : <lua> if server.secure then protocol = 'https://' else protocol = 'http://' end success,token = authorize_page('admin.sipi.org', 'administrator', extecteduser, expectedPassword) if not success then return end </lua> where expectedUser and extectedPassword are the user/password combination the user is expected to enter.","title":"Embedded LUA and enforcing SSL"},{"location":"lua/#file-uploads-to-sipi","text":"The SIPI specific LUA function allow the upload of files using POST requests with multipart/form-data content. The global variable server.uploads contains`the information about the uploads. The following variables and function help to deal with uploads: server.uploads : information about the files in the upload request. server.copyTmpfile : copies a fie from the upload location to the destination directory. In addition the file system functions that SIPI provides may be used. See the scripts upload.elua and do-upload.elua in the server directory, and upload.lua in the scripts directory for a working example.","title":"File uploads to SIPI"},{"location":"lua/#restful-api-and-custom-routes","text":"Custom routes to implement a RESTful API can be defined in Sipi's configuration file using the routes configuration variable. For example: routes = { { method = 'GET', route = '/status', script = 'get_repository_status.lua' }, { method = 'POST', route = '/make_thumbnail', script = 'make_image_thumbnail.lua' } } Sipi looks for these scripts in the directory specified by scriptdir in its configuration file. The first route that matches the beginning of the requested URL path will be used.","title":"RESTful API and custom routes"},{"location":"lua/#iiif-authentication-api-10-in-sipi","text":"The pre_flight function is also responsible for activating the IIIF Auth API. In order to do so, the pre_flight script returns a table that contains all necessary information. For details about the IIIF Authentication API 1.0 see the IIIF documentation . The following fields have to be returned by the pre_flight -function as LUA-table: type : String giving the type. Valid are: \"login\" , \"clickthrough\" , \"\"kiosk\" or \"external\" . cookieUrl : URL where to get a valid IIIF Auth cookie for this service. tokenUrl : URL where to get a valid IIIF Auth token for this service. confirmLabel : Label to display in confirmation box. description : Description for login window. failureDescription : Information, if login fails. failureHeader : Header for failure window. header : Header of login window label : Label of the login window In addition, the filepath has to be returns. A full response may look as follows: return { type = 'login', cookieUrl = 'https://localhost/iiif-cookie.html', tokenUrl = 'https://localhost/iiif-token.php', confirmLabel = 'Login to SIPI', description = 'This Example requires a demo login!', failureDescription = '<a href=\"http://example.org/policy\">Access Policy</a>', failureHeader = 'Authentication Failed', header = 'Please Log In', label = 'Login to SIPI', }, filepath SIPI will use this information returned by the pre_flight function to return the appropriate responses to the client requests based on the IIIF Authentication API 1.0. Check for support of the IIIF Authentication API 1.0 for mirador and universalviewer , both applications which suppport the IIIF standards.","title":"IIIF Authentication API 1.0 in SIPI"},{"location":"lua/#sipi-variables-available-to-lua-scripts","text":"There are many globally accessible LUA variables made available which reflext the configuration of SIPI and the state of the server and request. This variables a read only and created for every request.","title":"SIPI variables available to Lua scripts"},{"location":"lua/#sipi-configuration-variables","text":"This variables are defined ither in the configuration file if SIPI, in environemt variables at startup or as command line option when starting the server.","title":"SIPI configuration variables"},{"location":"lua/#confighostname","text":"config.hostname The hostname SIPI is configures to run on (see hostname in configuration description).","title":"config.hostname"},{"location":"lua/#configport","text":"config.port Portnumber where the SIPI server listens (see serverport in configuration description).","title":"config.port"},{"location":"lua/#configsslport","text":"config.sslport Portnumber for SSL connections of SIPI (see sslport in configuration description).","title":"config.sslport"},{"location":"lua/#configimgroot","text":"config.imgroot Root directory for IIIF-served images (see imgroot in configuration description).","title":"config.imgroot"},{"location":"lua/#configdocroot","text":"config.docroot Root directory for WEB-Server (see docroot in configuration description).","title":"config.docroot"},{"location":"lua/#configmax_temp_file_age","text":"config.max_temp_file_age maximum age of temporary files (see max_temp_file_age in configuration description).","title":"config.max_temp_file_age"},{"location":"lua/#configprefix_as_path","text":"config.prefix_as_path` true if the prefix should be used as path info (see prefix_as_path in configuration description).","title":"config.prefix_as_path"},{"location":"lua/#configinit_script","text":"config.init_script Path to initialization script (see initscript in configuration description).","title":"config.init_script"},{"location":"lua/#configscriptdir","text":"config.scriptdir Path to script directory. (see scriptdir in configuration description).","title":"config.scriptdir"},{"location":"lua/#configcache_dir","text":"config.cache_dir Path to cache directory for iIIF served images. (see cachedir in configuration description).","title":"config.cache_dir"},{"location":"lua/#configcache_size","text":"config.cache_size Maximal size of cache (see cachesize in configuration description).","title":"config.cache_size"},{"location":"lua/#configcache_n_files","text":"config.cache_n_files Maximal number of files in cache. (see cache_nfiles in configuration description).","title":"config.cache_n_files"},{"location":"lua/#configcache_hysteresis","text":"config.cache_hysteresis Amount of data to be purged if cache reaches maximum size. (see cache_hysteresis in configuration description).","title":"config.cache_hysteresis"},{"location":"lua/#configjpeg_quality","text":"config.jpeg_quality Unfortunately, the IIIF Image API does not allow to give a JPEG quality (=compression) on the IIIF URL. SIPI allows to configure the compression quality system wide with this parameter. Allowed values are in he range [1..100] where 1 the worst quality (and highest compression factor = smallest file size) and 100 the highest quality (with lowest compression factor = biggest file size). Please note that SIPI is not able to provide lossless compression for JPEG files. (see jpeg_quality in configuration description).","title":"config.jpeg_quality"},{"location":"lua/#configkeep_alive","text":"config.keep_alive Maximal keep-alive time for HTTP requests that ask for a keep-alive connection. (see keep_alive in configuration description).","title":"config.keep_alive"},{"location":"lua/#configthumb_size","text":"config.thumb_size Default thumbnail image size. (see thumb_size in configuration description).","title":"config.thumb_size"},{"location":"lua/#confign_threads","text":"config.n_threads Number of worker threads SIPI uses. (see nthreads in configuration description).","title":"config.n_threads"},{"location":"lua/#configmax_post_size","text":"config.max_post_size Maximal size of POST data allowed (see max_post_size in configuration description).","title":"config.max_post_size"},{"location":"lua/#configtmpdir","text":"config.tmpdir Temporary directory to store uploads. (see tmpdir in configuration description).","title":"config.tmpdir"},{"location":"lua/#configssl_certificate","text":"config.ssl_certificate Path to the SSL certificate that SIPI uses. (see ssl_certificate in configuration description).","title":"config.ssl/_certificate"},{"location":"lua/#configssl_key","text":"config.ssl_key Path to the SSL key that SIPI uses. (see ssl_key in configuration description).","title":"config.ssl/_key"},{"location":"lua/#configlogfile","text":"config.logfile Name of the logfile. SIPI is currently using the syslog facility and the logfile name is ignored. (see logfile in configuration description).","title":"config.logfile"},{"location":"lua/#configloglevel","text":"config.loglevel Indicates what should be logged. The variable contains a integer that corresponds to the syslog level. (see loglevel in configuration description).","title":"config.loglevel"},{"location":"lua/#configadminuser","text":"config.adminuser Name of admin user. (see user in configuration description).","title":"config.adminuser"},{"location":"lua/#configpassword","text":"config.password Password (plain text, not encrypted) of admin user ( use with caution )! (see password in configuration description).","title":"config.password"},{"location":"lua/#sipi-server-variables","text":"Sipi server variables are dependent on the incoming request and are created by SIPI automatically for each request.","title":"SIPI Server Variables"},{"location":"lua/#servermethod","text":"server.method The HTTP request method. Is one of OPTIONS , GET , HEAD , POST , PUT , DELETE , TRACE , CONNECT or OTHER .","title":"server.method"},{"location":"lua/#serverhas_openssl","text":"server.has_openssl true if OpenSSL is available. This variable is determined compilation time. Usually SSL should be included, but SIPI can be compiled without SSL support. There is no option in the configuration file for this.","title":"server.has_openssl"},{"location":"lua/#serversecure","text":"server.secure true if the connection was made over HTTPS using SSL.","title":"server.secure"},{"location":"lua/#serverhost","text":"server.host The hostname of the Sipi server that was used in the request.","title":"server.host"},{"location":"lua/#serverclient_ip","text":"server.client_ip The IPv4 or IPv6 address of the client connecting to Sipi.","title":"server.client_ip"},{"location":"lua/#serverclient_port","text":"server.client_port The port number of the client socket.","title":"server.client_port"},{"location":"lua/#serveruri","text":"server.uri The URL path used to access Sipi (does not include the hostname).","title":"server.uri"},{"location":"lua/#serverheader","text":"server.header A table containing all the HTTP request headers(in lowercase).","title":"server.header"},{"location":"lua/#servercookies","text":"server.cookies A table of the cookies that were sent with the request.","title":"server.cookies"},{"location":"lua/#serverget","text":"server.get A table of GET request parameters.","title":"server.get"},{"location":"lua/#serverpost","text":"server.post A table of POST or PUT request parameters.","title":"server.post"},{"location":"lua/#serverrequest","text":"server.request All request parameters.","title":"server.request"},{"location":"lua/#servercontent","text":"server.content If the request had a body, the variable contains the body data. Otherwise it's nil .","title":"server.content"},{"location":"lua/#servercontent_type","text":"server.content_type Returns the content type of the request. If there is no type or no content, this variable is nil .","title":"server.content_type"},{"location":"lua/#serveruploads","text":"server.uploads This is an array of upload parameters, one per file. Each one is a table containing: fieldname : the name of the form field. origname : the original filename. tmpname : a temporary path to the uploaded file. mimetype : the MIME type of the uploaded file as provided by the browser. filesize : the size of uploaded file in bytes. The upload can be accessed as follows: for index, value in pairs(server.uploads) do -- -- copy the uploaded file to the image repository using the original name -- server.copyTmpfile(index, config.imgdir .. '/' .. value[\"origname\"]) end","title":"server.uploads"},{"location":"lua/#knora-specific-variables","text":"The development of SIPI came out of the need to have a flexible, high performance IIIF server for the Swiss National research infrastructure Data and Service Center for the Humanities (DaSCH). The aim of the DaSCH is to guarantee long-term accessibility of research data from the Humanities. The operates a specialized platform Knora . The following variables are for internal use only.","title":"Knora-specific variables"},{"location":"lua/#configknora_path","text":"config.knora_path Path to knora REST API (only for SIPI used with Knora)","title":"config.knora_path"},{"location":"lua/#configknora_port","text":"config.knora_port Port that the Knora API uses","title":"config.knora_port"},{"location":"lua/#sipi-functions-available-to-lua-scripts","text":"Sipi provides the following functions that can be called from Lua scripts. Each function returns two values. The first value is true if the operation succeeded, false otherwise. If the operation succeeded, the second value is the result of the operation, otherwise it is an error message.","title":"SIPI functions available to Lua scripts"},{"location":"lua/#sipi-connection-functions","text":"These LUA function alter the way the HTTP connection is handled.","title":"SIPI Connection Functions"},{"location":"lua/#serversetbuffer","text":"success, errmsg = server.setBuffer([bufsize][,incsize]) Activates the the connection buffer. Optionally the buffer size and increment size can be given. Returns true, nil on success or false, errormsg on failure.","title":"server.setBuffer"},{"location":"lua/#serversendheader","text":"success, errormsg = server.sendHeader(key, value) Sets an HTTP response header. Returns true, nil on success or false, errormsg on failure.","title":"server.sendHeader"},{"location":"lua/#serversendcookie","text":"success, errormsg = server.sendCookie(key, value [, options-table]) Sets a cookie in the HTTP response. Returns true, nil on success or false, errormsg on failure. The optional options-table is a Lua table containing the following keys: path domain expires (value in seconds) secure (boolean) http_only (boolean)","title":"server.sendCookie"},{"location":"lua/#serversendstatus","text":"server.sendStatus(code) Sends an HTTP status code. This function is always successful and returns nothing.","title":"server.sendStatus"},{"location":"lua/#serverprint","text":"success, errormsg = server.print(values) Prints variables and/or strings over the HTTP connection to the client that originated the request. Returns true, nil on success or false, errormsg on failure.","title":"server.print"},{"location":"lua/#serverrequireauth","text":"success, table = server.requireAuth() This function retrieves HTTP authentication data that was supplied after sending a 'WWW-Authenticate' -header (e.g. by issuing a the following commands to enter the HTTP login dialog: server.setBuffer() server.sendStatus(401); server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') It returns true, table on success or false, errormsg on failure. The result of the authorization is returned as table with the following elements: status : Either BASIC , BEARER , NOAUTH (no authorization header) or ERROR username : A string containing the supplied username (only existing if stats is BASIC ) password : A string containing the supplied password (only existing if stats is BASIC ) token : A string containing the raw token information (only if status BEARER ) message : A string containing the error message (only if status ERROR ) Example: success, auth = server.requireAuth() if not success then server.sendStatus(501) server.print(\"Error in getting authentication scheme!\") return -1 end if auth.status == 'BASIC' then -- -- everything OK, let's create the token for further -- calls and ad it to a cookie -- if auth.username == config.adminuser and auth.password == config.password then tokendata = { iss = \"sipi.unibas.ch\", aud = \"knora.org\", user = auth.username } success, token = server.generate_jwt(tokendata) if not success then server.sendStatus(501) server.print(\"Could not generate JWT!\") return -1 end success, errormsg = server.sendCookie('sipi', token, {path = '/', expires = 3600}) if not success then server.sendStatus(501) server.print(\"Couldn't send cookie with JWT!\") return -1 end else server.sendStatus(401) server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') server.print(\"Wrong credentials!\") return -1 end elseif auth.status == 'BEARER' then success, jwt = server.decode_jwt(auth.token) if not success then server.sendStatus(501) server.print(\"Couldn't deocde JWT!\") return -1 end if (jwt.iss ~= 'sipi.unibas.ch') or (jwt.aud ~= 'knora.org') or (jwt.user ~= config.adminuser) then server.sendStatus(401) server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') return -1 end elseif auth.status == 'NOAUTH' then server.setBuffer() server.sendStatus(401); server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') return -1 else server.status(401) server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') return -1 end","title":"server.requireAuth"},{"location":"lua/#sipi-file-system-function","text":"These functions offer tools to manipuale files and directories, and to gather file information.","title":"SIPI File System Function"},{"location":"lua/#serverfsftype","text":"success, filetype = server.fs.ftype(filepath) Checks the filetype of a given filepath. Returns either true, filetype (with filetype one of \"FILE\" , \"DIRECTORY\" , \"CHARDEV\" , \"BLOCKDEV\" , \"LINK\" , \"SOCKET\" or \"UNKNOWN\" ) or false, errormsg .","title":"server.fs.ftype"},{"location":"lua/#serverfsmodtime","text":"success, modtime = server.fs.modtime(filepath) Retrieves the last modification date of a file in seconds since epoch UTC. Returns either true , modtime or false , errormsg .","title":"server.fs.modtime"},{"location":"lua/#serverfsis_readable","text":"success, readable = server.fs.is_readable(filepath) Checks if a file is readable. Returns true, readable (boolean) on success or false, errormsg on failure.","title":"server.fs.is_readable"},{"location":"lua/#serverfsis_writeable","text":"success, writeable = server.fs.is_writeable(filepath) Checks if a file is writeable. Returns true, writeable (boolean) on success or false, errormsg on failure.","title":"server.fs.is_writeable"},{"location":"lua/#serverfsis_executable","text":"success, errormsg = server.fs.is_executable(filepath) Checks if a file is executable. Returns true, executable (boolean) on success or false, errormsg on failure.","title":"server.fs.is_executable"},{"location":"lua/#serverfsexists","text":"success, exists = server.fs.exists(filepath) Checks if a file exists. Checks if a file exists. Returns true, exists (boolean) on success or false, errormsg on failure.","title":"server.fs.exists"},{"location":"lua/#serverfsunlink","text":"success, errormsg = server.fs.unlink(filename) Deletes a file from the file system. The file must exist and the user must have write access. Returns true, nil on success or false, errormsg on failure.","title":"server.fs.unlink"},{"location":"lua/#serverfsmkdir","text":"success, errormsg = server.fs.mkdir(dirname, [tonumber('0755', 8)]) Creates a new directory, optionally with the specified permissions. Returns true, nil on success or false, errormsg on failure.","title":"server.fs.mkdir"},{"location":"lua/#serverfsrmdir","text":"success, errormsg = server.fs.rmdir(dirname) Deletes a directory. Returns true, nil on success or false, errormsg on failure.","title":"server.fs.rmdir"},{"location":"lua/#serverfsgetcwd","text":"success, curdir = server.fs.getcwd() Gets the current working directory. Returns true, current_dir on success or false, errormsg on failure.","title":"server.fs.getcwd"},{"location":"lua/#serverfsreaddir","text":"success, filenames = server.fs.readdir(dirname) Gets the names of the files in a directory, not including . and .. . Returns true, table on success or false, errormsg on failure.","title":"server.fs.readdir"},{"location":"lua/#serverfschdir","text":"success, oldir = server.fs.chdir(newdir) Change working directory. Returns true, olddir on success or false, errormsg on failure.","title":"server.fs.chdir"},{"location":"lua/#serverfscopyfile","text":"success, errormsg = server.fs.copyFile(source, destination) Copies a file from source to destination. Returns true, nil on success or false, errormsg on failure.","title":"server.fs.copyFile"},{"location":"lua/#serverfsmovefile","text":"success, errormsg = server.fs.moveFile(from, to) Moves a file. The move connot cross filesystem boundaries! true, nil on success or false, errormsg on failure.","title":"server.fs.moveFile"},{"location":"lua/#other-helper-function","text":"","title":"Other Helper Function"},{"location":"lua/#serverhttp","text":"success, result = server.http(method, \"http://server.domain[:port]/path/file\" [, header] [, timeout]) Performs an HTTP request using curl. Currently implements only GET requests. Parameters: method : The HTTP request method. Currently must be \"GET\" . url : The HTTP URL. header : An optional table of key-value pairs representing HTTP request headers. timeout : An optional number of milliseconds until the connection times out. Authentication is not yet supported. The result is a table: result = { status_code = value -- HTTP status code returned erromsg = \"error description\" -- only if success is false header = { name = value [, name = value, ...] }, certificate = { -- only if HTTPS connection subject = value, issuer = value }, body = data, duration = milliseconds } Example: success, result = server.http(\"GET\", \"http://www.salsah.org/api/resources/1\", 100) if (result.success) then server.print(\"<table>\") server.print(\"<tr><th>Field</th><th>Value</th></tr>\") for k,v in pairs(server.header) do server.print(\"<tr><td>\", k, \"</td><td>\", v, \"</td></tr>\") end server.print(\"</table><hr/>\") server.print(\"Duration: \", result.duration, \" ms<br/><hr/>\") server.print(\"Body:<br/>\", result.body) else server.print(\"ERROR: \", result.errmsg) end","title":"server.http"},{"location":"lua/#servertable_to_json","text":"success, jsonstr = server.table\\_to\\_json(table) Converts a (nested) Lua table to a JSON string. Returns true, jsonstr on success or false, errormsg on failure.","title":"server.table_to_json"},{"location":"lua/#serverjson_to_table","text":"success, table = server.json_to_table(jsonstr) Converts a JSON string to a (nested) Lua table. Returns true, table on success or false, errormsg on failure.","title":"server.json_to_table"},{"location":"lua/#servergenerate_jwt","text":"success, token = server.generate_jwt(table) Generates a JSON Web Token (JWT) with the supplied table as payload. Returns true, token on success or false, errormsg on failure. The internal may contain arbitrary keys and/or may contains the JWT claims as follows. (The type IntDate is a number of seconds since 1970-01-01T0:0:0Z): iss (string => StringOrURI) OPT: principal that issued the JWT. exp (number => IntDate) OPT: expiration time on or after which the token MUST NOT be accepted for processing. nbf (number => IntDate) OPT: identifies the time before which the token MUST NOT be accepted for processing. iat (number => IntDate) OPT: identifies the time at which the JWT was issued. aud (string => StringOrURI) OPT: identifies the audience that the JWT is intended for. The audience value is a string, typically the base address of the resource being accessed, such as https://contoso.com . prn (string => StringOrURI) OPT: identifies the subject of the JWT. jti (string => String) OPT: provides a unique identifier for the JWT.","title":"server.generate_jwt"},{"location":"lua/#serverdecode_jwt","text":"success, table = server.decode_jwt(token) Decodes a JSON Web Token (JWT) and returns its content as table. Returns true, table on success or false, errormsg on failure.","title":"server.decode_jwt"},{"location":"lua/#serverparse_mimetype","text":"success, mimetype = server.parse_mimetype(str) Parses a mimtype HTTP header string and returns a pair containing the actual mimetype and the charset used (if available). It returns true, pair with pair as mimetype and charset on success, false, errormsg on failure.","title":"server.parse_mimetype"},{"location":"lua/#serverfile_mimetype","text":"success, table = server.file_mimetype(path) success, table = server.file_mimetype(index) Determines the mimetype of a file. The first form is used if the file path is known. The second form can be used for uploads by passing the upload file index. It returns true, table on success or false, errormsg on failure. The table has 2 members: - mimetype - charset","title":"server.file_mimetype"},{"location":"lua/#serverfile_mimeconsistency","text":"success, is_consistent = server.file_mimeconsistency(path) success, is_consistent = server.file_mimeconsistency(index) Checks if the file extension and the mimetype determined by the magic of the file is consistent. The first form requires a path (including the filename with extension), the second can be used for checking uploads by passing the file index. It returns true, is_consistent on success or false, errormsg in case of an error. is_consistent is true if the mimetype corresponds to the file extension.","title":"server.file_mimeconsistency"},{"location":"lua/#servercopytmpfile","text":"success, errormsg = server.copyTmpfile(from, to) Sipi saves each uploaded file in a temporary location (given by the config variable tmpdir ) and deletes it after the request has been served. This function is used to copy the file to another location where it can be retrieved later. Returns true, nil on success or false, errormsg on failure. Parameters: from : an index (integer value) of array server.uploads. target : destination path","title":"server.copyTmpfile"},{"location":"lua/#serversystime","text":"systime = server.systime() Returns the current system time on the server in seconds since epoch.","title":"server.systime"},{"location":"lua/#serverlog","text":"server.log(message, loglevel) Writes a message to syslog . Severity levels are: server.loglevel.LOG_EMERG server.loglevel.LOG_ALERT server.loglevel.LOG_CRIT server.loglevel.LOG_ERR server.loglevel.LOG_WARNING server.loglevel.LOG_NOTICE server.loglevel.LOG_INFO server.loglevel.LOG_DEBUG","title":"server.log"},{"location":"lua/#serveruuid","text":"success, uuid = server.uuid() Generates a random UUID version 4 identifier in canonical form, as described in RFC 4122 . Returns true, uuid on success or false, errormsg on failure.","title":"server.uuid"},{"location":"lua/#serveruuid62","text":"success, uuid62 = server.uuid62() Generates a Base62-encoded UUID. Returns true, uuid62 on success or false, errormsg on failure.","title":"server.uuid62"},{"location":"lua/#serveruuid_to_base62","text":"success, uuid62 = server.uuid_to_base62(uuid) Converts a canonical UUID string to a Base62-encoded UUID. Returns true, uuid62 on success or false, errormsg on failure.","title":"server.uuid_to_base62"},{"location":"lua/#serverbase62_to_uuid","text":"success, uuid = server.base62_to_uuid(uuid62) Converts a Base62-encoded UUID to canonical form. Returns true, uuid on success or false, errormsg on failure.","title":"server.base62_to_uuid"},{"location":"lua/#installing-lua-modules","text":"To install Lua modules that can be used in Lua scripts, use local/bin/luarocks . Make sure that the location where the modules are stored is in the Lua package path, which is printed by local/bin/lurocks path. The Lua paths will be used by the Lua interpreter when loading modules in a script with require (see Using LuaRocks to install packages in the current directory ). For example, using local/bin/luarocks install --local package , the package will be installed in ~/.luarocks/ . To include this path in the Lua's interpreter package search path, you can use an environment variable. Running local/bin/luarocks path outputs the code you can use to do so. Alternatively, you can build the package path at the beginning of a Lua file by setting package.path and package.cpath (see Running scripts with packages ).","title":"Installing Lua modules"},{"location":"running/","text":"Running Sipi After following the instructions in building, you will find the executable local/bin/sipi in the source tree. It can be run either as simple command-line image converter or as a server. Running Sipi As a Command-line Image Converter Convert an image file to another format: local/bin/sipi --format [output format] --fileIn [input file] [output file] Compare two image files: local/bin/sipi --Compare file1 --Compare file2 Running Sipi As a Server local/bin/sipi --config [config file] Sipi logs its operations using syslog . Command-line Options Options: --config filename, -c filename Configuration file for web server. --file fileIn, -f fileIn input file to be converted. Usage: sipi [options] -f fileIn fileout --format Value, -F Value Output format Value can be: jpx,jpg,tif,png. --ICC Value, -I Value Convert to ICC profile. Value can be: none,sRGB,AdobeRGB,GRAY. --quality Value, -q Value Quality (compression). Value can any integer between 1 and 100 --region x,y,w,h, -r x,y,w,h Select region of interest, where x,y,w,h are integer values --Reduce Value, -R Value Reduce image size by factor Value (cannot be used together with --size and --scale) --size w,h -s w,h Resize image to given size w,h (cannot be used together with --reduce and --scale) --Scale Value, -S Value Resize image by the given percentage Value (cannot be used together with --size and --reduce) --skipmeta Value, -k Value Skip the given metadata. Value can be none,all --mirror Value, -m Value Mirror the image. Value can be: none,horizontal,vertical --rotate Value, -o Value Rotate the image. by degree Value, angle between (0:360) --salsah, -s Special flag for SALSAH internal use --Compare file1 --Compare file2 or -C file1 -C file2 Compare two files --watermark file, -w file Add a watermark to the image --serverport Value, -p Value Port of the web server --nthreads Value, -t Value Number of threads for web server --imgroot Value, -i Value Root directory containing the images for the web server --loglevel Value, -l Value Logging level Value can be: DEBUG,INFO,NOTICE,WARNING,ERR,CRIT,ALERT,EMERG --help Print usage and exit. Configuration Files Sipi's configuration file is written in Lua . You can make your own configuration file by adapting config/sipi.config.lua . Check that the port number is correct and that your operating system's firewall does not block it. Set imgroot to the directory containing the files to be served. Create the directory cache in the top-level directory of the source tree. For more information, see the comments in config/sipi.config.lua . Using Sipi with Knora If you are using Sipi with Knora , you can adapt config/sipi.knora-config.lua . HTTPS Support Sipi supports SSL/TLS encryption if the OpenSSL library is installed. You will need to install a certificate; see config/sipi.config.lua for instructions. IIIF Prefixes Sipi supports IIIF Image API URLs . If the configuration property prefix_as_path is set to true , the IIIF prefix portion of the URL is interpreted as a subdirectory of imgroot , and Sipi looks for the requested image file in that subdirectory. Otherwise, it looks for the file in imgroot .","title":"Running"},{"location":"running/#running-sipi","text":"After following the instructions in building, you will find the executable local/bin/sipi in the source tree. It can be run either as simple command-line image converter or as a server.","title":"Running Sipi"},{"location":"running/#running-sipi-as-a-command-line-image-converter","text":"Convert an image file to another format: local/bin/sipi --format [output format] --fileIn [input file] [output file] Compare two image files: local/bin/sipi --Compare file1 --Compare file2","title":"Running Sipi As a Command-line Image Converter"},{"location":"running/#running-sipi-as-a-server","text":"local/bin/sipi --config [config file] Sipi logs its operations using syslog .","title":"Running Sipi As a Server"},{"location":"running/#command-line-options","text":"Options: --config filename, -c filename Configuration file for web server. --file fileIn, -f fileIn input file to be converted. Usage: sipi [options] -f fileIn fileout --format Value, -F Value Output format Value can be: jpx,jpg,tif,png. --ICC Value, -I Value Convert to ICC profile. Value can be: none,sRGB,AdobeRGB,GRAY. --quality Value, -q Value Quality (compression). Value can any integer between 1 and 100 --region x,y,w,h, -r x,y,w,h Select region of interest, where x,y,w,h are integer values --Reduce Value, -R Value Reduce image size by factor Value (cannot be used together with --size and --scale) --size w,h -s w,h Resize image to given size w,h (cannot be used together with --reduce and --scale) --Scale Value, -S Value Resize image by the given percentage Value (cannot be used together with --size and --reduce) --skipmeta Value, -k Value Skip the given metadata. Value can be none,all --mirror Value, -m Value Mirror the image. Value can be: none,horizontal,vertical --rotate Value, -o Value Rotate the image. by degree Value, angle between (0:360) --salsah, -s Special flag for SALSAH internal use --Compare file1 --Compare file2 or -C file1 -C file2 Compare two files --watermark file, -w file Add a watermark to the image --serverport Value, -p Value Port of the web server --nthreads Value, -t Value Number of threads for web server --imgroot Value, -i Value Root directory containing the images for the web server --loglevel Value, -l Value Logging level Value can be: DEBUG,INFO,NOTICE,WARNING,ERR,CRIT,ALERT,EMERG --help Print usage and exit.","title":"Command-line Options"},{"location":"running/#configuration-files","text":"Sipi's configuration file is written in Lua . You can make your own configuration file by adapting config/sipi.config.lua . Check that the port number is correct and that your operating system's firewall does not block it. Set imgroot to the directory containing the files to be served. Create the directory cache in the top-level directory of the source tree. For more information, see the comments in config/sipi.config.lua .","title":"Configuration Files"},{"location":"running/#using-sipi-with-knora","text":"If you are using Sipi with Knora , you can adapt config/sipi.knora-config.lua .","title":"Using Sipi with Knora"},{"location":"running/#https-support","text":"Sipi supports SSL/TLS encryption if the OpenSSL library is installed. You will need to install a certificate; see config/sipi.config.lua for instructions.","title":"HTTPS Support"},{"location":"running/#iiif-prefixes","text":"Sipi supports IIIF Image API URLs . If the configuration property prefix_as_path is set to true , the IIIF prefix portion of the URL is interpreted as a subdirectory of imgroot , and Sipi looks for the requested image file in that subdirectory. Otherwise, it looks for the file in imgroot .","title":"IIIF Prefixes"},{"location":"sipi/","text":"Basic Information and Reference This section provides the basic information to use SIPI as a high performance, versatile media server implementing the IIIF standards that can be used in many different settings, from a small standalone server providing basic metadata to the deployment in a complex environment. For more information about the IIIF standard see https://iiif.io . The basic idea is that an image or rectangular region of an image can be downloaded (e.g. to the browser) with a given width and height, rotation, image quality and format. All parameters are provided with the IIIF conformant URL that has the following form: http(s)://{server}/{prefix}/{identifier}/{region}/{size}/{rotation}/{quality}.{format} The parts do have the following meaning: {server} : The DNS name of the server, eg. iiif.dasch.swiss . The server may include a portnumber, eg. iiif2.dasch.swiss:8080 . {prefix} : A path (that may include / 's) to organize the assets. Usually the prefix reflect the internal directory or folder hierarchy. However this can be overridden using special features of SIPI (see pre-flight-script and sipi configuration file). {identifier} : The identifier of the requested image. By default, it is the filename and its extension. {region} : a region of interest that should be displayed. full indicates that the whole image is being requested. For more details see IIIF regions {size} : The size of the displayed image (part). max indicates the the \"natural\" maximal resolution should be used. For more details see IIIF size {rotations} : The image can be rotated and mirrored before being transmitted to the client. SIPI allows for arbitrary rotations. The Value 0 indicates no rotation. For more details see IIIF rotation {quality} : The quality parameter determines whether the image is delivered in color, grayscale or black and white. Valid values are: default : the \"natural\" quality of the original image color : A color representation gray : A gray value representation bitonal : A bitonal representation All quality values are supported by SIPI - {format} : The file format that should be delivered. SIPI supports the following formats, irrelevant on the format the image as in the repository of SIPI: - jpg : The image is delivered as JPEG image. Unfortunately the IIIF standard does not allow the dynamic selection of the compression ratio used in creating the JPEG. However, a server wide rate may be set in the configuration file. - tif : The image is delivered as TIFF image. - png : The image is delivered as PNG image. - pdf : The image is delivered as PDF document. Note : *If the file in the SIPI repository is a multi-page PDF, a SIPI-specific extensions allows to address single pages and deliver them as images in any format. - jpx : The image is delivered as JPEG2000 image. The SIPI Executable The SIPI executable is a statically linked program that can be started as - command line tool to perform image operations, mainly format conversions - as server deamon that provides IIIF conforming media server Using SIPI as Command Line Tool The SIPI command line mode can be used for the following tasks: Format Conversions: /path/to/sipi infile outfile [options] Print Information about File and Metadata: /path/to/sipi -x infile /path/to/sipi --query infile Compare two Images Pixelwise The images may have different formats: if the have exactely the same pixels, they are considered identical). Metadata is ignored for comparison: /path/to/sipi -C file1 file2 /path/to/sipi --compare file1 file2 General Options for the Command Line Use In command line mode, SIPI supports the following options: -h , --help : Display a short help with all options available -F <fmt> , --format <fmt> : The format of the output file. Valid are jpx , jp2 , jpg , png and pdf . -I <profile> , --icc <profile> : Convert the outfile to the given ICC color profile. Supported profiles are sRGB , AdobeRGB and GRAY . -q <num> , --quality <num> : Only used for the JPEG format. Ignored for all other formats. Its a number between 1 and 100, where 1 is equivalent to the highest compression ratio and lowest quality, 100 to the lowest compression ration and highest quality of the output image. -n <num> , --pagenum <num> : Only for input files in multi-page PDF format: sets the page that should be converted. Ignored for all other input file formats. -r <x> <y> <nx> <ny> , --region <x> <y> <nx> <ny> : Selects a region of interest that should be converted. Needs 4 integer values: left_upper_corner_X , left_upper_corner_Y , width , height . -s <iiif-size> , --size <iif-size> : The size of the resulting image. The option requires a string parameter formatted according to the size-syntax of IIIF see IIIF-Size . Not giving this parameters results in having the maximalsize (as the value \"max\" would give). -s <num> , --scale <num> : Scaling the image size by the given number (interpreted as percentage). Percentage must be given as integer value. It may be bigger than 100 to upscale an image. -R <num> , --reduce <num> : Reduce the size of the image by the given factor. Thus -R 2 would resize the image to half of the original size. Using --reduce is usually much faster than using --scale , e.g. --reduce 2 is faster than --scale 50 . -m <val> , --mirror <val> : Takes either horizontal or vertical as parameter to mirror the image appropriately. -o <angle> , --rotate <angle> : Rotates the image by the given angle. The angle must be a floating point (or integer) value between 0.0 and w60.0 . -k , --skipmeta : Strip all metadata from inputfile. -w <filepath> , --watermark <filepath> : Overlays a watermark to the output image. must be a single channel, gray valued TIFF. That is, the TIFF file must have the following tag values: SAMPLESPERPIXEL = 1, BITSPERSAMPLE = 8, PHOTOMETRIC = PHOTOMETRIC_MINISBLACK. JPEG2000 Specific Options Usually, the SIPI command line tool is used to create JPEG2000 images suitable for a IIIF repository. SIPI supports the following JPEG2000 specific options. For a in detail description of these options consult the kakadu documentation! --Sprofile <profile> : The following JPEG2000 profiles are supported: PROFILE0 , PROFILE1 , PROFILE2 , PART2 , CINEMA2K , CINEMA4K , BROADCAST , CINEMA2S , CINEMA4S , CINEMASS , IMF . Default: PART2 . --rates <string> : One or more bit-rates (see kdu_compress help!). A value \"-1\" may be used in place of the first bit-rate in the list to indicate that the final quality layer should include all compressed bits. --Clayers <num> :Number of quality layers. Default: 8. --Clevels <num> : Number of wavelet decomposition levels, or stages. Default: 8. --Corder <val> : Progression order. The four character identifiers have the following interpretation: L=layer; R=resolution; C=component; P=position. The first character in the identifier refers to the index which progresses most slowly, while the last refers to the index which progresses most quickly. Thus must be one of LRCP , RLCP , RPCL , PCRL , CPRL , Default: RPCL . --Stiles <string> : Tiles dimensions \"{tx,ty}\" . Default: \"{256,256}\" . --Cprecincts <string> : Precinct dimensions \"{px,py}\" (must be powers of 2). Default: \"{256,256}\" . --Cblk <string> : Nominal code-block dimensions \"{dx,dy}\" (must be powers of 2, no less than 4 and no greater than 1024, whose product may not exceed 4096). Default: \"{64,64}\" . --Cuse_sop <val> : Include SOP markers (i.e., resync markers). Default: yes. Using SIPI as IIIF Media Server In order to use SIPI as IIIF media server, some setup work has to be done. The configuration of SIPI can be done using a configuration file (that is written in LUA) and/or using environment variables, and/or command line options. The priority is as follows: configuration file parameters are overwritten by environment variables are overwritten by command line options . The SIPI server requires a few directories to be setup and listed in the configuration file. Then the SIPI server is launched as follows: /path/to/sipi --config /path/to/config-file.lua SIPI specific extensions to IIIF SIPI implements some backwards compatible, non-standard extensions to the IIIF Image API: Page access to PDF's SIPI allows to access the pages of a multipage pdf in any format using the well known IIIF image API. The prerequisite is that the file is available in the repository in PDF format. Only the identifier section of the IIIF syntax has to be extended with a non-standard extensions: adding a @ -character followed by an integer between 1 the number of pages retrieves this page of the PDF as if it would a a single standard image an can be rendered to any supported format: https://iiif.my.server/images/mydoc.pdf@5/10,10,800,500/!500,500/0/default.jpg The above command would extract page #5 from the PDF, convert it into an image, select the given region and return it a JPEG image. This, with this feature, a 3rd party viewer such a mirador or universalviewer may be used for scrolling through the pages of a PDF file. In order to better support full PDF files, SIPI also adds the total number of pages to the info.json response if being requested for a PDF file (e.g. with the URL http//iiif.myserver.org/images/test.pdf/info.json ) in addition to the standard info.json -format: { ... \"width\": 2480, \"height\": 3508, \"numpages\": 27, ... } Access to a raw files Sometimes it max be usefull to store non-image files such as XML-sidecars, manifests as JSON or complete PDF's etc. in the same environment as the images. For this reason supports an extension of the IIIF API: http(s)://{server}/{prefix}/{identifier}/file The /file -path at the end of the URL makes SIPI to send the file as it is. Thus, for example a manfifest file could be accessed by https://iiif.my.server/images/myimage.json/file This works also for PDF's. The URL https://iiif.my.server/images/mydocument.pdf/file will download in toto to be opened by an external viewer or the webapplication. It is possible to use the IIIF- info.json syntax also on non-image files. In this case the info.json has the following format: { \"@context\": \"http://sipi.io/api/file/3/context.json\", \"id\": \"http://localhost:1024/images/test.csv\", \"mimeType\": \"text/comma-separated-values\", \"fileSize\": 327 } Setup of SIPI Directories SIPI needs the following directories and files setup and accessible (the real names of the directories must be indicated in the configuration file). The following configuration parameters are in the sipi -table of the configuration script: imgroot=path : This is the top-directory of the media file repository. SIPI should at least have read access to it. If SIPI is used to upload and convert files, it must also have write access. The path may be given as absolute path or as relative path. Cmdline option: --imgroot Environment variable: SIPI_IMGROOT Default: ./images initscript=path/to/init.lua : SIPI needs a minmal set of LUA functions that can be adapted to the local installation. These mandatory functions are definied in a init-script (usually it can be found in the config directory where also the configuration file is located). Cmdline option: --initscript Environment variable: SIPI_INITSCRIPT Default: ./config/sipi.init.lua tmpdir=path : For the support of multipart POST SIPI requires read/write access to a directory to save temporary files. Cmdline option: --tmpdir Environment variable: SIPI_IMGROOT Default: ./tmp scriptdir=path : Path to the directory where the LUA-scripts for the routes (e.g. RESTful services) can be found. Cmdline option: --scriptdir Environment variable: SIPI_SCRIPTDIR Default: ./scripts cachedir=path : SIPI may optionally use a cache directory to store converted image in order to avoid computationally intensive conversions if a specific variant is requested several times. Sipi starts with a warning if the cache directory is defined but not existing. Cmdline option: --cachedir Environment variable: SIPI_CACHEDIR Default: ./cache In addition, SIPI can act as a webserver that offers image upload and conversion as web service. In order to use this feature, a server directory has to be defined. This definition ist in the fileserver -table of the configuration file: docroot=path : Path to the document root of the SIPI web server. Cmdline option: --docroot Environment variable: SIPI_DOCROOT Default: ./server SIPI Configuration Parameters The following configuration parameters are used by the SIPI server: hostname=dns-name : The DNS name that SIPI shall show to the outside world. It should be the dns name the client uses to access the SIPI server (and not internal hostnames by proxies etc.). Cmdline option: --hostname Environment variable: SIPI_HOSTNAME Default: localhost port=portnum : Portnumber SIPI should listen on for incoming HTTP requests. Cmdline option: --serverport Environment variable: SIPI_SERVERPORT Default: 80 ssl_port=portnum : Portnumber SIPI should listen on for incoming SHTTP requests (using SSL). Cmdline option: --sslport Environment variable: SIPI_SSLPORT Default: 443 nthreads=num : Number of worker threads that SIPI allocates. SIPI is a mutlithreaded server and pre-allocates a given number of working threads that can be configured. Cmdline option: --nthreads Environment variable: SIPI_NTHREADS Default: number of hardware cores as given by std::thread::hardware_concurrency() prefix_as_path=bool : If true , the prefix is used as path within the image root directory. If false, the prefix is ignored and it is assumed that all images are directly located in the image root. Cmdline option: --pathprefix Environment variable: SIPI_PATHPREFIX Default: false ssl_certificate=path : Path to the SSL certificate. Is mandatory if SSL is to be used. Cmdline option: --sslcert Environment variable: SIPI_SSLCERTIFICATE Default: ./certificate/certificate.pem ssl_key=path : Path to the SSL key file. Is mandatory if SSL is to be used. Cmdline option: --sslkey Environment variable: SIPI_SSLKEY Default: ./certificate/key.pem jwt_secret=string : Shared secret to encode web tokens. Cmdline option: --jwtkey Environment variable: SIPI_JWTKEY Default: UP 4888, nice 4-8-4 steam engine max_post_size=amount : Maximal size a file upload may have. The amount has the form \" \" where number is an integer value and type an \"M\" for Megabytes, \"G\" for Gigabytes and \"\" (empty) for bytes. Cmdline option: --maxpost Environment variable: SIPI_MAXPOSTSIZE Default: 300M keep_alive : Number of seconds a connection (socket) remains open at maximum (\"keep-alive\"), if a client requests a \"keep-alive\" connection in the request header. For more information see Keep-Alive . Cmdline option: --keepalive Environment variable: SIPI_KEEPALIVE Default: 5 jpeg_quality=num : Compression parameter when producing JPEG output. Must be a number between 1 and 100. Unfortunately, the IIIF Image API does not allow to give a JPEG quality (=compression) on the IIIF URL. SIPI allows to configure the compression quality system wide with this parameter. Allowed values are in he range [1..100] where 1 the worst quality (and highest compression factor = smallest file size) and 100 the highest quality (with lowest compression factor = biggest file size). Please note that SIPI is not able to provide lossless compression for JPEG files. Cmdline option: --quality Environment variable: SIPI_JPEGQUALITY Default: 60 thumb_size=string : Default size for thumbnails. Parameter must be IIIF conformant size string. This configuration parameter can be used to define a default value for creating thumbnails. It has no direct implications but can be used in LUA scripts (e.g. the pre_flight-function). Cmdline option: --thumbsize Environment variable: SIPI_THUMBSIZE Default: !128,128 logfile=path : SIPI uses syslog as logging facility. The logging name is Sipi . It supports the following levels: \"EMERGENCY\", \"ALERT\", \"CRITICAL\", \"ERROR\", \"WARNING\", \"NOTICE\", \"INFORMATIONAL\", \"DEBUG\". Cmdline option: --logfile Environment variable: SIPI_LOGFILE Default: Sipi loglevel=level : SIPI uses syslog as logging facility. The logging name is Sipi . It supports the following levels: \"EMERGENCY\", \"ALERT\", \"CRITICAL\", \"ERROR\", \"WARNING\", \"NOTICE\", \"INFORMATIONAL\", \"DEBUG\". Cmdline option: --loglevel Environment variable: SIPI_LOGLEVEL Default: DEBUG max_temp_file_age=num : The maximum allowed age of temporary files (in seconds) before they are deleted. Cmdline option: --maxtmpage Environment variable: SIPI_MAXTMPAGE Default: 86400 (one day) Cache Configuration SIPI may optionally use a cache directory to store converted image in order to avoid computationally intensive conversions if a specific variant is requested several times. The cache is based on timestamps and the canonical IIIF URL. Before an image is being converted, the canonical URL is determined. If a file associated with this canonical URL is in the cache directory, the timestamp of the original file in the repository is compated to the cached file. If the cached file is newer, it will be served. If the file in the repository is newer, the cache file (which is outdated) will be deleted and replaced be the newly converted repository file (that is being sent to the client). The following configuration parameters determine the behaviour of the cache: cachedir=path : SIPI may optionally use a cache directory to store converted image in order to avoid computationally intensive conversions if a specific variant is requested several times. Sipi starts with a warning if the cache directory is defined but not existing. Cmdline option: --cachedir Environment variable: SIPI_CACHEDIR Default: ./cache cachesize=amount : The maximal size of the cache. The cache will be purged if either the maximal size or maximal number of files is reached. The amount has the form \" M\" with M indication Megabytes. Cmdline option: --cachesize Environment variable: SIPI_CACHESIZE Default: 200M cache_nfiles=num : The maximal number of files to be cached. The cache will be purged if either the maximal size or maximal number of files is reached. Cmdline option: --cachenfiles Environment variable: SIPI_CACHENFILES Default: 200 cache_hysteresis=float : If the cache becomes full, the given percentage of file space is marked for reuse and purged. Cmdline option: --cachehysteresis Environment variable: SIPI_CACHEHYSTERESIS Default: 0.15 Configuration of the HTTP File Server SIPI offers HTTP file server for HTML and other files. Files with the ending .elua are HTTP-files with embeded LUA code. Everything between the ... tags is interpreted as LUA code and the output embedded in the data stream for the client. All configurations for the HTTP server are in the fileserver table: docroot=path : Path to the document root of the file server. Cmdline option: --docroot Environment variable: SSIPI_DOCROOT Default: ./server wwwroute=string : Route for the file server should respond to requests.That is, a file with the name \"dada.html\" is accessed with http://dnsname/server/dada.html , if the wwwroute is set to /server . Cmdline option: --wwwroute Environment variable: SIPI_WWWROUTE Default: /server Configuration of Administrator Access SIPI allows special administrator access for some tasks. In order to allow for this, an administrator has to be defined as follows: admin = { -- -- username of admin user -- user = 'admin', -- -- Administration password -- password = 'Sipi-Admin' } If You're using the administrator user, please make sure that the config file is not exposed! Routing Table SIPI allows to implement RESTful interfaces or other services based on LUA-scripts which are located in the scripts directory. In order to use these LUA-scripts as endpoints, the appropriate routes have to be defined in the routes table. An entry has the following form: - method : the HTTP request. Supported are GET , POST , PUT and DELETE . - route : A URL path that may contain / 's. - script : Name of the LUA script in the script directory. Thus, the routing section of a SIPI configuration file may look as follows: routes = { { method = 'DELETE', route = '/api/cache', script = 'cache.lua' }, { method = 'GET', route = '/api/cache', script = 'cache.lua' }, { method = 'POST', route = '/api/upload', script = 'upload.lua' }, { method = 'GET', route = '/sqlite', script = 'test_sqlite.lua' } }","title":"Basic information and Reference"},{"location":"sipi/#basic-information-and-reference","text":"This section provides the basic information to use SIPI as a high performance, versatile media server implementing the IIIF standards that can be used in many different settings, from a small standalone server providing basic metadata to the deployment in a complex environment. For more information about the IIIF standard see https://iiif.io . The basic idea is that an image or rectangular region of an image can be downloaded (e.g. to the browser) with a given width and height, rotation, image quality and format. All parameters are provided with the IIIF conformant URL that has the following form: http(s)://{server}/{prefix}/{identifier}/{region}/{size}/{rotation}/{quality}.{format} The parts do have the following meaning: {server} : The DNS name of the server, eg. iiif.dasch.swiss . The server may include a portnumber, eg. iiif2.dasch.swiss:8080 . {prefix} : A path (that may include / 's) to organize the assets. Usually the prefix reflect the internal directory or folder hierarchy. However this can be overridden using special features of SIPI (see pre-flight-script and sipi configuration file). {identifier} : The identifier of the requested image. By default, it is the filename and its extension. {region} : a region of interest that should be displayed. full indicates that the whole image is being requested. For more details see IIIF regions {size} : The size of the displayed image (part). max indicates the the \"natural\" maximal resolution should be used. For more details see IIIF size {rotations} : The image can be rotated and mirrored before being transmitted to the client. SIPI allows for arbitrary rotations. The Value 0 indicates no rotation. For more details see IIIF rotation {quality} : The quality parameter determines whether the image is delivered in color, grayscale or black and white. Valid values are: default : the \"natural\" quality of the original image color : A color representation gray : A gray value representation bitonal : A bitonal representation All quality values are supported by SIPI - {format} : The file format that should be delivered. SIPI supports the following formats, irrelevant on the format the image as in the repository of SIPI: - jpg : The image is delivered as JPEG image. Unfortunately the IIIF standard does not allow the dynamic selection of the compression ratio used in creating the JPEG. However, a server wide rate may be set in the configuration file. - tif : The image is delivered as TIFF image. - png : The image is delivered as PNG image. - pdf : The image is delivered as PDF document. Note : *If the file in the SIPI repository is a multi-page PDF, a SIPI-specific extensions allows to address single pages and deliver them as images in any format. - jpx : The image is delivered as JPEG2000 image.","title":"Basic Information and Reference"},{"location":"sipi/#the-sipi-executable","text":"The SIPI executable is a statically linked program that can be started as - command line tool to perform image operations, mainly format conversions - as server deamon that provides IIIF conforming media server","title":"The SIPI Executable"},{"location":"sipi/#using-sipi-as-command-line-tool","text":"The SIPI command line mode can be used for the following tasks:","title":"Using SIPI as Command Line Tool"},{"location":"sipi/#format-conversions","text":"/path/to/sipi infile outfile [options]","title":"Format Conversions:"},{"location":"sipi/#print-information-about-file-and-metadata","text":"/path/to/sipi -x infile /path/to/sipi --query infile","title":"Print Information about File and Metadata:"},{"location":"sipi/#compare-two-images-pixelwise","text":"The images may have different formats: if the have exactely the same pixels, they are considered identical). Metadata is ignored for comparison: /path/to/sipi -C file1 file2 /path/to/sipi --compare file1 file2","title":"Compare two Images Pixelwise"},{"location":"sipi/#general-options-for-the-command-line-use","text":"In command line mode, SIPI supports the following options: -h , --help : Display a short help with all options available -F <fmt> , --format <fmt> : The format of the output file. Valid are jpx , jp2 , jpg , png and pdf . -I <profile> , --icc <profile> : Convert the outfile to the given ICC color profile. Supported profiles are sRGB , AdobeRGB and GRAY . -q <num> , --quality <num> : Only used for the JPEG format. Ignored for all other formats. Its a number between 1 and 100, where 1 is equivalent to the highest compression ratio and lowest quality, 100 to the lowest compression ration and highest quality of the output image. -n <num> , --pagenum <num> : Only for input files in multi-page PDF format: sets the page that should be converted. Ignored for all other input file formats. -r <x> <y> <nx> <ny> , --region <x> <y> <nx> <ny> : Selects a region of interest that should be converted. Needs 4 integer values: left_upper_corner_X , left_upper_corner_Y , width , height . -s <iiif-size> , --size <iif-size> : The size of the resulting image. The option requires a string parameter formatted according to the size-syntax of IIIF see IIIF-Size . Not giving this parameters results in having the maximalsize (as the value \"max\" would give). -s <num> , --scale <num> : Scaling the image size by the given number (interpreted as percentage). Percentage must be given as integer value. It may be bigger than 100 to upscale an image. -R <num> , --reduce <num> : Reduce the size of the image by the given factor. Thus -R 2 would resize the image to half of the original size. Using --reduce is usually much faster than using --scale , e.g. --reduce 2 is faster than --scale 50 . -m <val> , --mirror <val> : Takes either horizontal or vertical as parameter to mirror the image appropriately. -o <angle> , --rotate <angle> : Rotates the image by the given angle. The angle must be a floating point (or integer) value between 0.0 and w60.0 . -k , --skipmeta : Strip all metadata from inputfile. -w <filepath> , --watermark <filepath> : Overlays a watermark to the output image. must be a single channel, gray valued TIFF. That is, the TIFF file must have the following tag values: SAMPLESPERPIXEL = 1, BITSPERSAMPLE = 8, PHOTOMETRIC = PHOTOMETRIC_MINISBLACK.","title":"General Options for the Command Line Use"},{"location":"sipi/#jpeg2000-specific-options","text":"Usually, the SIPI command line tool is used to create JPEG2000 images suitable for a IIIF repository. SIPI supports the following JPEG2000 specific options. For a in detail description of these options consult the kakadu documentation! --Sprofile <profile> : The following JPEG2000 profiles are supported: PROFILE0 , PROFILE1 , PROFILE2 , PART2 , CINEMA2K , CINEMA4K , BROADCAST , CINEMA2S , CINEMA4S , CINEMASS , IMF . Default: PART2 . --rates <string> : One or more bit-rates (see kdu_compress help!). A value \"-1\" may be used in place of the first bit-rate in the list to indicate that the final quality layer should include all compressed bits. --Clayers <num> :Number of quality layers. Default: 8. --Clevels <num> : Number of wavelet decomposition levels, or stages. Default: 8. --Corder <val> : Progression order. The four character identifiers have the following interpretation: L=layer; R=resolution; C=component; P=position. The first character in the identifier refers to the index which progresses most slowly, while the last refers to the index which progresses most quickly. Thus must be one of LRCP , RLCP , RPCL , PCRL , CPRL , Default: RPCL . --Stiles <string> : Tiles dimensions \"{tx,ty}\" . Default: \"{256,256}\" . --Cprecincts <string> : Precinct dimensions \"{px,py}\" (must be powers of 2). Default: \"{256,256}\" . --Cblk <string> : Nominal code-block dimensions \"{dx,dy}\" (must be powers of 2, no less than 4 and no greater than 1024, whose product may not exceed 4096). Default: \"{64,64}\" . --Cuse_sop <val> : Include SOP markers (i.e., resync markers). Default: yes.","title":"JPEG2000 Specific Options"},{"location":"sipi/#using-sipi-as-iiif-media-server","text":"In order to use SIPI as IIIF media server, some setup work has to be done. The configuration of SIPI can be done using a configuration file (that is written in LUA) and/or using environment variables, and/or command line options. The priority is as follows: configuration file parameters are overwritten by environment variables are overwritten by command line options . The SIPI server requires a few directories to be setup and listed in the configuration file. Then the SIPI server is launched as follows: /path/to/sipi --config /path/to/config-file.lua","title":"Using SIPI as IIIF Media Server"},{"location":"sipi/#sipi-specific-extensions-to-iiif","text":"SIPI implements some backwards compatible, non-standard extensions to the IIIF Image API:","title":"SIPI specific extensions to IIIF"},{"location":"sipi/#page-access-to-pdfs","text":"SIPI allows to access the pages of a multipage pdf in any format using the well known IIIF image API. The prerequisite is that the file is available in the repository in PDF format. Only the identifier section of the IIIF syntax has to be extended with a non-standard extensions: adding a @ -character followed by an integer between 1 the number of pages retrieves this page of the PDF as if it would a a single standard image an can be rendered to any supported format: https://iiif.my.server/images/mydoc.pdf@5/10,10,800,500/!500,500/0/default.jpg The above command would extract page #5 from the PDF, convert it into an image, select the given region and return it a JPEG image. This, with this feature, a 3rd party viewer such a mirador or universalviewer may be used for scrolling through the pages of a PDF file. In order to better support full PDF files, SIPI also adds the total number of pages to the info.json response if being requested for a PDF file (e.g. with the URL http//iiif.myserver.org/images/test.pdf/info.json ) in addition to the standard info.json -format: { ... \"width\": 2480, \"height\": 3508, \"numpages\": 27, ... }","title":"Page access to PDF's"},{"location":"sipi/#access-to-a-raw-files","text":"Sometimes it max be usefull to store non-image files such as XML-sidecars, manifests as JSON or complete PDF's etc. in the same environment as the images. For this reason supports an extension of the IIIF API: http(s)://{server}/{prefix}/{identifier}/file The /file -path at the end of the URL makes SIPI to send the file as it is. Thus, for example a manfifest file could be accessed by https://iiif.my.server/images/myimage.json/file This works also for PDF's. The URL https://iiif.my.server/images/mydocument.pdf/file will download in toto to be opened by an external viewer or the webapplication. It is possible to use the IIIF- info.json syntax also on non-image files. In this case the info.json has the following format: { \"@context\": \"http://sipi.io/api/file/3/context.json\", \"id\": \"http://localhost:1024/images/test.csv\", \"mimeType\": \"text/comma-separated-values\", \"fileSize\": 327 }","title":"Access to a raw files"},{"location":"sipi/#setup-of-sipi-directories","text":"SIPI needs the following directories and files setup and accessible (the real names of the directories must be indicated in the configuration file). The following configuration parameters are in the sipi -table of the configuration script: imgroot=path : This is the top-directory of the media file repository. SIPI should at least have read access to it. If SIPI is used to upload and convert files, it must also have write access. The path may be given as absolute path or as relative path. Cmdline option: --imgroot Environment variable: SIPI_IMGROOT Default: ./images initscript=path/to/init.lua : SIPI needs a minmal set of LUA functions that can be adapted to the local installation. These mandatory functions are definied in a init-script (usually it can be found in the config directory where also the configuration file is located). Cmdline option: --initscript Environment variable: SIPI_INITSCRIPT Default: ./config/sipi.init.lua tmpdir=path : For the support of multipart POST SIPI requires read/write access to a directory to save temporary files. Cmdline option: --tmpdir Environment variable: SIPI_IMGROOT Default: ./tmp scriptdir=path : Path to the directory where the LUA-scripts for the routes (e.g. RESTful services) can be found. Cmdline option: --scriptdir Environment variable: SIPI_SCRIPTDIR Default: ./scripts cachedir=path : SIPI may optionally use a cache directory to store converted image in order to avoid computationally intensive conversions if a specific variant is requested several times. Sipi starts with a warning if the cache directory is defined but not existing. Cmdline option: --cachedir Environment variable: SIPI_CACHEDIR Default: ./cache In addition, SIPI can act as a webserver that offers image upload and conversion as web service. In order to use this feature, a server directory has to be defined. This definition ist in the fileserver -table of the configuration file: docroot=path : Path to the document root of the SIPI web server. Cmdline option: --docroot Environment variable: SIPI_DOCROOT Default: ./server","title":"Setup of SIPI Directories"},{"location":"sipi/#sipi-configuration-parameters","text":"The following configuration parameters are used by the SIPI server: hostname=dns-name : The DNS name that SIPI shall show to the outside world. It should be the dns name the client uses to access the SIPI server (and not internal hostnames by proxies etc.). Cmdline option: --hostname Environment variable: SIPI_HOSTNAME Default: localhost port=portnum : Portnumber SIPI should listen on for incoming HTTP requests. Cmdline option: --serverport Environment variable: SIPI_SERVERPORT Default: 80 ssl_port=portnum : Portnumber SIPI should listen on for incoming SHTTP requests (using SSL). Cmdline option: --sslport Environment variable: SIPI_SSLPORT Default: 443 nthreads=num : Number of worker threads that SIPI allocates. SIPI is a mutlithreaded server and pre-allocates a given number of working threads that can be configured. Cmdline option: --nthreads Environment variable: SIPI_NTHREADS Default: number of hardware cores as given by std::thread::hardware_concurrency() prefix_as_path=bool : If true , the prefix is used as path within the image root directory. If false, the prefix is ignored and it is assumed that all images are directly located in the image root. Cmdline option: --pathprefix Environment variable: SIPI_PATHPREFIX Default: false ssl_certificate=path : Path to the SSL certificate. Is mandatory if SSL is to be used. Cmdline option: --sslcert Environment variable: SIPI_SSLCERTIFICATE Default: ./certificate/certificate.pem ssl_key=path : Path to the SSL key file. Is mandatory if SSL is to be used. Cmdline option: --sslkey Environment variable: SIPI_SSLKEY Default: ./certificate/key.pem jwt_secret=string : Shared secret to encode web tokens. Cmdline option: --jwtkey Environment variable: SIPI_JWTKEY Default: UP 4888, nice 4-8-4 steam engine max_post_size=amount : Maximal size a file upload may have. The amount has the form \" \" where number is an integer value and type an \"M\" for Megabytes, \"G\" for Gigabytes and \"\" (empty) for bytes. Cmdline option: --maxpost Environment variable: SIPI_MAXPOSTSIZE Default: 300M keep_alive : Number of seconds a connection (socket) remains open at maximum (\"keep-alive\"), if a client requests a \"keep-alive\" connection in the request header. For more information see Keep-Alive . Cmdline option: --keepalive Environment variable: SIPI_KEEPALIVE Default: 5 jpeg_quality=num : Compression parameter when producing JPEG output. Must be a number between 1 and 100. Unfortunately, the IIIF Image API does not allow to give a JPEG quality (=compression) on the IIIF URL. SIPI allows to configure the compression quality system wide with this parameter. Allowed values are in he range [1..100] where 1 the worst quality (and highest compression factor = smallest file size) and 100 the highest quality (with lowest compression factor = biggest file size). Please note that SIPI is not able to provide lossless compression for JPEG files. Cmdline option: --quality Environment variable: SIPI_JPEGQUALITY Default: 60 thumb_size=string : Default size for thumbnails. Parameter must be IIIF conformant size string. This configuration parameter can be used to define a default value for creating thumbnails. It has no direct implications but can be used in LUA scripts (e.g. the pre_flight-function). Cmdline option: --thumbsize Environment variable: SIPI_THUMBSIZE Default: !128,128 logfile=path : SIPI uses syslog as logging facility. The logging name is Sipi . It supports the following levels: \"EMERGENCY\", \"ALERT\", \"CRITICAL\", \"ERROR\", \"WARNING\", \"NOTICE\", \"INFORMATIONAL\", \"DEBUG\". Cmdline option: --logfile Environment variable: SIPI_LOGFILE Default: Sipi loglevel=level : SIPI uses syslog as logging facility. The logging name is Sipi . It supports the following levels: \"EMERGENCY\", \"ALERT\", \"CRITICAL\", \"ERROR\", \"WARNING\", \"NOTICE\", \"INFORMATIONAL\", \"DEBUG\". Cmdline option: --loglevel Environment variable: SIPI_LOGLEVEL Default: DEBUG max_temp_file_age=num : The maximum allowed age of temporary files (in seconds) before they are deleted. Cmdline option: --maxtmpage Environment variable: SIPI_MAXTMPAGE Default: 86400 (one day)","title":"SIPI Configuration Parameters"},{"location":"sipi/#cache-configuration","text":"SIPI may optionally use a cache directory to store converted image in order to avoid computationally intensive conversions if a specific variant is requested several times. The cache is based on timestamps and the canonical IIIF URL. Before an image is being converted, the canonical URL is determined. If a file associated with this canonical URL is in the cache directory, the timestamp of the original file in the repository is compated to the cached file. If the cached file is newer, it will be served. If the file in the repository is newer, the cache file (which is outdated) will be deleted and replaced be the newly converted repository file (that is being sent to the client). The following configuration parameters determine the behaviour of the cache: cachedir=path : SIPI may optionally use a cache directory to store converted image in order to avoid computationally intensive conversions if a specific variant is requested several times. Sipi starts with a warning if the cache directory is defined but not existing. Cmdline option: --cachedir Environment variable: SIPI_CACHEDIR Default: ./cache cachesize=amount : The maximal size of the cache. The cache will be purged if either the maximal size or maximal number of files is reached. The amount has the form \" M\" with M indication Megabytes. Cmdline option: --cachesize Environment variable: SIPI_CACHESIZE Default: 200M cache_nfiles=num : The maximal number of files to be cached. The cache will be purged if either the maximal size or maximal number of files is reached. Cmdline option: --cachenfiles Environment variable: SIPI_CACHENFILES Default: 200 cache_hysteresis=float : If the cache becomes full, the given percentage of file space is marked for reuse and purged. Cmdline option: --cachehysteresis Environment variable: SIPI_CACHEHYSTERESIS Default: 0.15","title":"Cache Configuration"},{"location":"sipi/#configuration-of-the-http-file-server","text":"SIPI offers HTTP file server for HTML and other files. Files with the ending .elua are HTTP-files with embeded LUA code. Everything between the ... tags is interpreted as LUA code and the output embedded in the data stream for the client. All configurations for the HTTP server are in the fileserver table: docroot=path : Path to the document root of the file server. Cmdline option: --docroot Environment variable: SSIPI_DOCROOT Default: ./server wwwroute=string : Route for the file server should respond to requests.That is, a file with the name \"dada.html\" is accessed with http://dnsname/server/dada.html , if the wwwroute is set to /server . Cmdline option: --wwwroute Environment variable: SIPI_WWWROUTE Default: /server","title":"Configuration of the HTTP File Server"},{"location":"sipi/#configuration-of-administrator-access","text":"SIPI allows special administrator access for some tasks. In order to allow for this, an administrator has to be defined as follows: admin = { -- -- username of admin user -- user = 'admin', -- -- Administration password -- password = 'Sipi-Admin' } If You're using the administrator user, please make sure that the config file is not exposed!","title":"Configuration of Administrator Access"},{"location":"sipi/#routing-table","text":"SIPI allows to implement RESTful interfaces or other services based on LUA-scripts which are located in the scripts directory. In order to use these LUA-scripts as endpoints, the appropriate routes have to be defined in the routes table. An entry has the following form: - method : the HTTP request. Supported are GET , POST , PUT and DELETE . - route : A URL path that may contain / 's. - script : Name of the LUA script in the script directory. Thus, the routing section of a SIPI configuration file may look as follows: routes = { { method = 'DELETE', route = '/api/cache', script = 'cache.lua' }, { method = 'GET', route = '/api/cache', script = 'cache.lua' }, { method = 'POST', route = '/api/upload', script = 'upload.lua' }, { method = 'GET', route = '/sqlite', script = 'test_sqlite.lua' } }","title":"Routing Table"},{"location":"sqlite/","text":"Using SQLite in SIPI Sipi supports SQLite 3 databases, which can be accessed from Lua scripts. You should use pcall to handle errors that may be returned by SQLite. Opening an SQLite Database db = sqlite(path_to_db, access) This creates a new opaque database object. The parameters are: path_to_db : path to the sqlite3 database file. access : Method of opening the database. Allowed are 'RO' : readonly access. The file must exist and the SPIP server must have read access to it. 'RW' : read and write access. The file must exist and the SPIP server must have read/write access to it. 'CRW' : If the database file does not exist, it will be created and opened with read/write access. To destroy the database object and free all resources, you can do this: db = ~db However, Lua's garbage collection will destroy the database object and free all resources when they are no longer used. Preparing a Query The SIPI sqlite interface supports direct queries as well as prepared statements. A direct query is constructed as follows: qry = db << 'SELECT * FROM image' Or, if you want to use a prepared query statement: qry = db << 'INSERT INTO image (id, description) VALUES (?,?)' The result of the << operator ( qry ) will then be a query object containing a prepared query. If the query object is not needed anymore, it may be destroyed: qry = ~qry Query objects should be destroyed explicitly if not needed any longer. Executing a Query Excuting (calling) a query objects gets the next row of data. If there are no more rows, nil is returned. The row is returned as array of values. row = qry() while (row) do print(row[0], ' -> ', row[1]) row = qry() end Or with a prepared statement: row = qry('SGV_1960_00315', 'This is an image of a steam engine...') The second way is used for prepared queries that contain parameters.","title":"Sqlite3 integration"},{"location":"sqlite/#using-sqlite-in-sipi","text":"Sipi supports SQLite 3 databases, which can be accessed from Lua scripts. You should use pcall to handle errors that may be returned by SQLite.","title":"Using SQLite in SIPI"},{"location":"sqlite/#opening-an-sqlite-database","text":"db = sqlite(path_to_db, access) This creates a new opaque database object. The parameters are: path_to_db : path to the sqlite3 database file. access : Method of opening the database. Allowed are 'RO' : readonly access. The file must exist and the SPIP server must have read access to it. 'RW' : read and write access. The file must exist and the SPIP server must have read/write access to it. 'CRW' : If the database file does not exist, it will be created and opened with read/write access. To destroy the database object and free all resources, you can do this: db = ~db However, Lua's garbage collection will destroy the database object and free all resources when they are no longer used.","title":"Opening an SQLite Database"},{"location":"sqlite/#preparing-a-query","text":"The SIPI sqlite interface supports direct queries as well as prepared statements. A direct query is constructed as follows: qry = db << 'SELECT * FROM image' Or, if you want to use a prepared query statement: qry = db << 'INSERT INTO image (id, description) VALUES (?,?)' The result of the << operator ( qry ) will then be a query object containing a prepared query. If the query object is not needed anymore, it may be destroyed: qry = ~qry Query objects should be destroyed explicitly if not needed any longer.","title":"Preparing a Query"},{"location":"sqlite/#executing-a-query","text":"Excuting (calling) a query objects gets the next row of data. If there are no more rows, nil is returned. The row is returned as array of values. row = qry() while (row) do print(row[0], ' -> ', row[1]) row = qry() end Or with a prepared statement: row = qry('SGV_1960_00315', 'This is an image of a steam engine...') The second way is used for prepared queries that contain parameters.","title":"Executing a Query"},{"location":"0-release-notes/","text":"Main releases v3.1.0 Release Notes See the release 3.1.0 on GitHub. New features: Added sidecar support (Kakadu) Published on Dockerhub https://hub.docker.com/r/daschswiss/sipi under the V3.1.0 tag. v3.0.1 Release Notes See the release 3.0.1 on GitHub. New features: Compliant with the IIIF Image API 3.0 Published on Dockerhub https://hub.docker.com/r/daschswiss/sipi (new URL) under the V3.0.1 tag. Bug fixes: Fix parse URL crash v2.0.0 Release Notes See the release 2.0.0 on GitHub. New features: Published on Dockerhub https://hub.docker.com/r/dhlabbasel/sipi under the v2.0.0 tag. v1.4.0 Release Notes See the release 1.4.0 on GitHub. New features: Added latest kakadu version v7_A_4-01727L.zip support for CIELab for both 8- and 16-bit images try/catch for ICC profiles that are not supported by kakadu. These profiles are added to the \"essential metadata\" in order to be reinstated if the JPX is converted back to a TIFF or JPEG. added more unit tests Bug fixes: 16 Bit PNG images are now teated correctly by byteswapping of the data (htons), since PNG uses network byte order which is usually noit zthe host byte order on intel processors alpha channels are treated correctly with JPEG2000 The parameter names in a multidata/form-data POST request now have the double quotes removed v1.3.0 Release Notes See the release 1.3.0 on GitHub. New features: Added latest kakadu version v7_A_4-01727L.zip support for CIELab for both 8- and 16-bit images try/catch for ICC profiles that are not supported by kakadu. These profiles are added to the \"essential metadata\" in order to be reinstated if the JPX is converted back to a TIFF or JPEG. added more unit tests Bug fixes: 16 Bit PNG images are now teated correctly by byteswapping of the data (htons), since PNG uses network byte order which is usually noit zthe host byte order on intel processors alpha channels are treated correctly with JPEG2000 The parameter names in a multidata/form-data POST request now have the double quotes removed v1.2.0 Release Notes See the release 1.2.0 on GitHub. v1.1.0 Release Notes See the release 1.1.0 on GitHub.","title":"Release-Notes"},{"location":"0-release-notes/#main-releases","text":"","title":"Main releases"},{"location":"0-release-notes/#v310-release-notes","text":"See the release 3.1.0 on GitHub.","title":"v3.1.0 Release Notes"},{"location":"0-release-notes/#new-features","text":"Added sidecar support (Kakadu) Published on Dockerhub https://hub.docker.com/r/daschswiss/sipi under the V3.1.0 tag.","title":"New features:"},{"location":"0-release-notes/#v301-release-notes","text":"See the release 3.0.1 on GitHub.","title":"v3.0.1 Release Notes"},{"location":"0-release-notes/#new-features_1","text":"Compliant with the IIIF Image API 3.0 Published on Dockerhub https://hub.docker.com/r/daschswiss/sipi (new URL) under the V3.0.1 tag.","title":"New features:"},{"location":"0-release-notes/#bug-fixes","text":"Fix parse URL crash","title":"Bug fixes:"},{"location":"0-release-notes/#v200-release-notes","text":"See the release 2.0.0 on GitHub.","title":"v2.0.0 Release Notes"},{"location":"0-release-notes/#new-features_2","text":"Published on Dockerhub https://hub.docker.com/r/dhlabbasel/sipi under the v2.0.0 tag.","title":"New features:"},{"location":"0-release-notes/#v140-release-notes","text":"See the release 1.4.0 on GitHub.","title":"v1.4.0 Release Notes"},{"location":"0-release-notes/#new-features_3","text":"Added latest kakadu version v7_A_4-01727L.zip support for CIELab for both 8- and 16-bit images try/catch for ICC profiles that are not supported by kakadu. These profiles are added to the \"essential metadata\" in order to be reinstated if the JPX is converted back to a TIFF or JPEG. added more unit tests","title":"New features:"},{"location":"0-release-notes/#bug-fixes_1","text":"16 Bit PNG images are now teated correctly by byteswapping of the data (htons), since PNG uses network byte order which is usually noit zthe host byte order on intel processors alpha channels are treated correctly with JPEG2000 The parameter names in a multidata/form-data POST request now have the double quotes removed","title":"Bug fixes:"},{"location":"0-release-notes/#v130-release-notes","text":"See the release 1.3.0 on GitHub.","title":"v1.3.0 Release Notes"},{"location":"0-release-notes/#new-features_4","text":"Added latest kakadu version v7_A_4-01727L.zip support for CIELab for both 8- and 16-bit images try/catch for ICC profiles that are not supported by kakadu. These profiles are added to the \"essential metadata\" in order to be reinstated if the JPX is converted back to a TIFF or JPEG. added more unit tests","title":"New features:"},{"location":"0-release-notes/#bug-fixes_2","text":"16 Bit PNG images are now teated correctly by byteswapping of the data (htons), since PNG uses network byte order which is usually noit zthe host byte order on intel processors alpha channels are treated correctly with JPEG2000 The parameter names in a multidata/form-data POST request now have the double quotes removed","title":"Bug fixes:"},{"location":"0-release-notes/#v120-release-notes","text":"See the release 1.2.0 on GitHub.","title":"v1.2.0 Release Notes"},{"location":"0-release-notes/#v110-release-notes","text":"See the release 1.1.0 on GitHub.","title":"v1.1.0 Release Notes"}]}